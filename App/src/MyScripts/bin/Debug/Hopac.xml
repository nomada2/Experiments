<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Hopac</name></assembly>
<members>
<member name="T:Hopac.BoundedMb`1">
<summary>
 Represents a bounded synchronous mailbox for many to many communication.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Hopac.EmbeddedJobBuilder">
<summary>
 A builder for embedded jobs.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Hopac.EmbeddedJob`1">
<summary>
 Represents a job to be embedded within a computation built upon jobs.
</summary>
</member>
<member name="M:Hopac.IAsyncDisposable.DisposeAsync">
<summary>
 Returns a job that needs to be executed to dispose the resource.  The
 returned job should wait until the resource is properly disposed.
</summary>
</member>
<member name="T:Hopac.IAsyncDisposable">
<summary>
 An experimental interface for asynchronously disposable resources.  See
 also: `usingAsync`.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Hopac.JobBuilder">
<summary>
 Expression builder type for jobs.
</summary>
</member>
<member name="T:Hopac.Void">
<summary>
 A type that has no public constructors to indicate that a job or function
 does not return normally.
</summary>
</member>
<member name="M:Hopac.Alt.paranoid``1(Hopac.Alt{``0})">
<summary>
 Given an alternative, creates a new alternative that behaves exactly like
 the given alternative, except that the new alternative obviously cannot be
 directly downcast to the underlying type of the given alternative.  This
 operation is provided for debugging purposes.  You can always break
 abstractions using reflection.  See also: `Job.paranoid`.
</summary>
</member>
<member name="M:Hopac.Alt.tryFinallyJob``1(Hopac.Alt{``0},Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Implements a variation of the `try-finally` exception handling construct
 for alternatives.  The given action, specified as a job, is executed after
 the alternative has been committed to, whether the alternative fails or
 completes successfully.  Note that the action is not executed in case the
 alternative is not committed to.  Use `withNackJob` to attach the action
 to the non-committed case.
</summary>
</member>
<member name="M:Hopac.Alt.tryFinallyFun``1(Hopac.Alt{``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Implements a variation of the `try-finally` exception handling construct
 for alternatives.  The given action, specified as a function, is executed
 after the alternative has been committed to, whether the alternative fails
 or completes successfully.  Note that the action is not executed in case
 the alternative is not committed to.  Use `withNackJob` to attach the
 action to the non-committed case.
</summary>
</member>
<member name="M:Hopac.Alt.tryIn``4(Hopac.Alt{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{System.Exception,``3})">
<summary>
 Implements the `try-in-unless` exception handling construct for
 alternatives.  Both of the continuation jobs `&apos;x -&gt; Job&lt;&apos;y&gt;`, for success,
 and `exn -&gt; Job&lt;&apos;y&gt;`, for failure, are invoked from a tail position.

 Exceptions from both before and after the commit point can be handled.  An
 exception that occurs before a commit point, from the user code in a
 `guard`, `delay`, or `withNackJob`, results in treating that exception as
 the commit point.

 Note you can also use function or job level exception handling before the
 commit point within the user code in a `guard`, `delay`, or `withNackJob`.
</summary>
</member>
<member name="M:Hopac.Alt.Ignore``1(Hopac.Alt{``0})">
<summary>
 `Ignore xA` is equivalent to `xA |&gt;&gt;? fun _ -&gt; ()`.
</summary>
</member>
<member name="M:Hopac.Alt.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Alt{``0})">
<summary>
 `xA |&gt; map x2y` is equivalent to `xA |&gt; wrap (x2y &gt;&gt; result)`.  This is
 the same as `|&gt;&gt;?` with the arguments flipped.
</summary>
</member>
<member name="M:Hopac.Alt.wrap``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Alt{``0})">
<summary>
 Creates an alternative whose result is passed to the given job constructor
 and processed with the resulting job after the given alternative has been
 committed to.  This is the same as `&gt;&gt;=?` with the arguments flipped.
</summary>
</member>
<member name="M:Hopac.Alt.chooser``2(System.Collections.Generic.IEnumerable{``0})">
<summary>
 `chooser xAs` is like `choose xAs` except that the order in which the
 alternatives from the sequence are considered will be determined at random
 each time the alternative is used.  See also: `&lt;~&gt;?`.
</summary>
</member>
<member name="M:Hopac.Alt.choosy``2(``0[])">
<summary>
 `choosy xAs` (read: choose array) is an optimized version of `choose xAs`
 when `xAs` is an array.  Do not write `choosy (Seq.toArray xAs)` instead
 of `choose xAs` unless the resulting alternative is reused many times.
</summary>
</member>
<member name="M:Hopac.Alt.choose``2(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates an alternative that is available when any one of the given
 alternatives is.  See also: `choosy`, `&lt;|&gt;?`.

 Note that `choose []` is equivalent to `never ()`.
</summary>
</member>
<member name="M:Hopac.Alt.wrapAbortFun``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit},Hopac.Alt{``0})">
<summary>
 `wrapAbortFun u2u xA` is equivalent to `wrapAbortJob (Job.thunk u2u) xA`.
</summary>
</member>
<member name="">

</member>
<member name="M:Hopac.Alt.wrapAbortJob``1(Hopac.Job{Microsoft.FSharp.Core.Unit},Hopac.Alt{``0})">
<summary>
 Returns a new alternative that that makes it so that the given job will be
 started as a separated concurrent job if the given alternative isn&apos;t the
 one being committed to.  See also: `wrapAbortFun`, `withNackJob`.
</summary>
</member>
<member name="M:Hopac.Alt.withNackFun``2(Microsoft.FSharp.Core.FSharpFunc{Hopac.Promise{Microsoft.FSharp.Core.Unit},``0})">
<summary>
 `withNackFun n2xA` is equivalent to `withNackJob (Job.lift n2xA)`.
</summary>
</member>
<member name="">

</member>
<member name="M:Hopac.Alt.withNackJob``3(Microsoft.FSharp.Core.FSharpFunc{Hopac.Promise{Microsoft.FSharp.Core.Unit},``0})">
<summary>
 Creates an alternative that is computed at instantiation time with the
 given job constructed with a negative acknowledgment alternative.  See
 also: `guard`.
</summary>
</member>
<member name="M:Hopac.Alt.random``2(Microsoft.FSharp.Core.FSharpFunc{System.UInt64,``0})">
<summary>
 Creates an alternative that is computed at instantiation time with the
 the given function, which will be called with a pseudo random 64-bit
 unsigned integer.  See also: `Random.bind`.
</summary>
</member>
<member name="M:Hopac.Alt.delay``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Creates an alternative that is computed at instantiation time with the
 given thunk.

 `delay` is an optimized weaker form of `guard` that can be used when no
 concurrent operations beyond the returned alternative are required by the
 encapsulated request protocol.
</summary>
</member>
<member name="M:Hopac.Alt.guard``2(Hopac.Job{``0})">
<summary>
 Creates an alternative that is computed at instantiation time with the
 given job.  See also: `withNackJob`.
</summary>
</member>
<member name="M:Hopac.Alt.raises``1(System.Exception)">
<summary>
 Creates an alternative that has the effect of raising the specified
 exception.  `raises e` is equivalent to `delay &lt;| fun () -&gt; raise e`.
</summary>
</member>
<member name="M:Hopac.Alt.once``1(``0)">
<summary>
 Returns an alternative that can be committed to once and that produces the
 given value.
</summary>
</member>
<member name="M:Hopac.Alt.zero">
<summary>
 Returns an alternative that is never available.  `zero ()` is an optimized
 version of `never ()`.
</summary>
</member>
<member name="M:Hopac.Alt.never``1">
<summary>
 Creates an alternative that is never available.

 Note that synchronizing on `never ()`, without other alternatives, is
 equivalent to performing `abort ()`.
</summary>
</member>
<member name="M:Hopac.Alt.unit">
<summary>
 Returns an alternative that is always available and results in the unit
 value.  `unit ()` is an optimized version of `always ()`.
</summary>
</member>
<member name="M:Hopac.Alt.always``1(``0)">
<summary>
 Creates an alternative that is always available and results in the given
 value.

 Note that when there are alternatives immediately available in a choice,
 the first such alternative will be committed to.
</summary>
</member>
<member name="M:Hopac.Alt.Infixes.op_LessPlusGreaterQmark``2(Hopac.Alt{``0},Hopac.Alt{``1})">
<summary>
 An alternative that is equivalent to first committing to either one of
 the given alternatives and then committing to the other alternative.
 Note that this is not the same as committing to both of the alternatives
 in a single transaction.  Such an operation would require a more complex
 synchronization protocol like with the so called Transactional Events.
</summary>
</member>
<member name="M:Hopac.Alt.Infixes.op_GreaterGreaterBangQmark``2(Hopac.Alt{``0},System.Exception)">
<summary>
 `xA &gt;&gt;!? e` is equivalent to `xA &gt;&gt;=? fun _ -&gt; raise e`.
</summary>
</member>
<member name="M:Hopac.Alt.Infixes.op_GreaterGreaterPercentQmark``2(Hopac.Alt{``0},``1)">
<summary>
 `xA &gt;&gt;%? y` is equivalent to `xA &gt;&gt;=? fun _ -&gt; result y`.
</summary>
</member>
<member name="M:Hopac.Alt.Infixes.op_BarGreaterGreaterQmark``2(Hopac.Alt{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 `xA |&gt;&gt;? x2y` is equivalent to `xA &gt;&gt;=? (x2y &gt;&gt; result)`.  This is the
 same as `map` with the arguments flipped.
</summary>
</member>
<member name="M:Hopac.Alt.Infixes.op_DotGreaterGreaterQmark``2(Hopac.Alt{``0},Hopac.Job{``1})">
<summary>
 `xA .&gt;&gt;? yJ` is equivalent to `xA &gt;&gt;=? fun x -&gt; yJ &gt;&gt;% x`.
</summary>
</member>
<member name="M:Hopac.Alt.Infixes.op_GreaterGreaterDotQmark``2(Hopac.Alt{``0},Hopac.Job{``1})">
<summary>
 `xA &gt;&gt;.? yJ` is equivalent to `xA &gt;&gt;=? fun _ -&gt; yJ`.
</summary>
</member>
<member name="M:Hopac.Alt.Infixes.op_GreaterGreaterEqualsQmark``3(Hopac.Alt{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Creates an alternative whose result is passed to the given job
 constructor and processed with the resulting job after the given
 alternative has been committed to.  This is the same as `wrap` with the
 arguments flipped.
</summary>
</member>
<member name="M:Hopac.Alt.Infixes.op_LessTwiddleGreaterQmark``1(Hopac.Alt{``0},Hopac.Alt{``0})">
<summary>
 `xA1 &lt;~&gt;? xA2` is like `xA1 &lt;|&gt;? xA2` except that the order in which
 `xA1` and `xA2` are considered is determined at random every time the
 alternative is used.  See also: `chooser`.
</summary>
</member>
<member name="M:Hopac.Alt.Infixes.op_LessBarGreaterQmark``1(Hopac.Alt{``0},Hopac.Alt{``0})">
<summary>
 Creates an alternative that is available when either of the given
 alternatives is available.  `xA1 &lt;|&gt;? xA2` is an optimized version of
 `choose [xA1; xA2]`.  See also: `choosy`.
</summary>
</member>
<member name="T:Hopac.Alt.Infixes">
<summary>
 Infix operators on alternatives.  You can open this module to bring all
 of the infix operators into scope.
</summary>
</member>
<member name="T:Hopac.Alt">
<summary>
 Operations on first-class synchronous operations or alternatives.
</summary>
</member>
<member name="M:Hopac.BoundedMb.take``1(Hopac.BoundedMb{``0})">
<summary>
 Selective synchronous operation to take a message from a bounded mailbox.
 `take` operations are processed in FIFO order and become enabled as soon
 as there are messages in the bounded buffer.  If the buffer capacity is
 `0`, `take` behaves exactly like `Ch.take`.
</summary>
</member>
<member name="M:Hopac.BoundedMb.put``1(Hopac.BoundedMb{``0},``0)">
<summary>
 Selective synchronous operation to put a message to a bounded mailbox.
 `put` operations are processed in FIFO order and become enabled as soon as
 there is room in the bounded buffer.  If the buffer capacity is `0`, `put`
 behaves exactly like `Ch.give`.
</summary>
</member>
<member name="M:Hopac.BoundedMb.create``1(System.Int32)">
<summary>
 Returns a job that creates a new bounded mailbox with a buffer of the
 specified maximum capacity.  Note that a bounded mailbox with a capacity
 of `0` behaves exactly the same as a channel, `Ch&lt;_&gt;`.
</summary>
</member>
<member name="T:Hopac.BoundedMb">
<summary>
 Operations on bounded synchronous mailboxes.
</summary>
</member>
<member name="M:Hopac.Ch.send``1(Hopac.Ch{``0},``0)">
<summary>
 Creates a job that sends a value to another job on the given channel.  A
 send operation is asynchronous.  In other words, a send operation does not
 wait for another job to give the value to.
</summary>
</member>
<member name="M:Hopac.Ch.take``1(Hopac.Ch{``0})">
<summary>
 Creates an alternative that, at instantiation time, offers to take a value
 from another job on the given channel, and becomes available when another
 job offers to give a value.
</summary>
</member>
<member name="M:Hopac.Ch.give``1(Hopac.Ch{``0},``0)">
<summary>
 Creates an alternative that, at instantiation time, offers to give the
 given value on the given channel, and becomes available when another job
 offers to take the value.  See also: `&lt;--`.
</summary>
</member>
<member name="M:Hopac.Ch.create``1">
<summary>
 Creates a job that creates a new channel.
</summary>
</member>
<member name="M:Hopac.Ch.Try.take``1(Hopac.Ch{``0})">
<summary>
 Creates a job that attempts to take a value from another job waiting on
 the given channel.  Note that the other side of the communication must
 be blocked on the channel for communication to happen.
</summary>
</member>
<member name="M:Hopac.Ch.Try.give``1(Hopac.Ch{``0},``0)">
<summary>
 Creates a job that attempts to give a value to another job waiting on
 the given channel.  The result indicates whether a value was given or
 not.  Note that the other side of the communication must be blocked on
 the channel for communication to happen.
</summary>
</member>
<member name="T:Hopac.Ch.Try">
<summary>
 Polling, or non-blocking, operations on synchronous channels.
</summary>
</member>
<member name="M:Hopac.Ch.Global.send``1(Hopac.Ch{``0},``0)">
<summary>
 Sends the given value to the specified channel.  `Ch.Global.send xCh x`
 is equivalent to `Ch.send xCh x |&gt; TopLevel.start`.

 Note that using this function in a job workflow is not optimal and you
 should use `Ch.send` instead.
</summary>
</member>
<member name="T:Hopac.Ch.Global">
<summary>
 Operations bound to the global scheduler.
</summary>
</member>
<member name="M:Hopac.Ch.Now.create``1">
<summary>
 Creates a new channel.
</summary>
</member>
<member name="T:Hopac.Ch.Now">
<summary>
 Immediate or non-workflow operations on synchronous channels.
</summary>
</member>
<member name="T:Hopac.Ch">
<summary>
 Operations on synchronous channels.
</summary>
</member>
<member name="M:Hopac.Extensions.IObservable`1.get_onceAlt``1(System.IObservable{``0})">
<summary>
 `xO.onceAlt` is equivalent to `xO.oneAltOn null`.  Note that it is often
 necessary to specify the synchronization context to subscribe on.  See
 also: `Observable.SubscribeOn`.
</summary>
</member>
<member name="M:Hopac.Extensions.IObservable`1.get_onceAltOnMain``1(System.IObservable{``0})">
<summary>
 This is equivalent to calling `onceAltOn` with the main synchronization
 context.  The application must call `Hopac.Extensions.Async.setMain` to
 configure Hopac with the main synchronization context.
</summary>
</member>
<member name="M:Hopac.Extensions.IObservable`1.onceAltOn``1(System.IObservable{``0},System.Threading.SynchronizationContext)">
<summary>
 Creates an alternative that, when instantiated, subscribes to the
 observable on the specified synchronization context for at most one
 event.  Passing `null` as the synchronization context means that the
 subscribe and unsubscribe actions are performed on an unspecified
 thread.
</summary>
</member>
<member name="M:Hopac.Extensions.Task.startJob.Static``1(Hopac.Job{``0})">
<summary>
 Creates a job that starts the given job as a separate concurrent job,
 whose result can be obtained from the returned task.
</summary>
</member>
<member name="M:Hopac.Extensions.Task.bindJob.Static``2(System.Threading.Tasks.Task,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 `bindJob (uT, u2xJ)` is equivalent to `awaitJob uT &gt;&gt;= u2xJ`.
</summary>
</member>
<member name="M:Hopac.Extensions.Task.bindJob.Static``3(System.Threading.Tasks.Task{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 `bindJob (xT, x2yJ)` is equivalent to `awaitJob xT &gt;&gt;= x2yJ`.
</summary>
</member>
<member name="M:Hopac.Extensions.Task.awaitJob.Static(System.Threading.Tasks.Task)">
<summary>
 Creates a job that waits until the given task finishes.  Note that this
 does not start the task.  Make sure that the task is started correctly.
</summary>
</member>
<member name="M:Hopac.Extensions.Task.awaitJob.Static``1(System.Threading.Tasks.Task{``0})">
<summary>
 Creates a job that waits for the given task to finish and then returns
 the result of the task.  Note that this does not start the task.  Make
 sure that the task is started correctly.
</summary>
</member>
<member name="M:Hopac.Extensions.asyncOn(System.Threading.SynchronizationContext,Hopac.Scheduler)">
<summary>
 Builder for an async operation started on the given synchronization
 context with jobs on the specified scheduler wrapped as a job.
</summary>
</member>
<member name="T:Hopac.Extensions.OnCompleted">
<summary>
 Raised by `onceAltOn` when the associated observable signals the
 `OnCompleted` event.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Hopac.Extensions.Async.OnWithSchedulerBuilder">
<summary>
 Builder for async workflows.  The methods in this builder delegate to
 the default `async` builder.
</summary>
</member>
<member name="M:Hopac.Extensions.Async.getMain">
<summary>
 Gets the main synchronization context.  The main synchronization context
 must be set by application code using `setMain` before calling this
 function.
</summary>
</member>
<member name="M:Hopac.Extensions.Async.setMain(System.Threading.SynchronizationContext)">
<summary>
 Sets the main synchronization context.  This must be called by
 application code in order to use operations such as `onceAltOnMain` and
 `TopLevel.onMain`
</summary>
</member>
<member name="M:Hopac.Extensions.Async.ofJobOn``1(Hopac.Scheduler,Hopac.Job{``0})">
<summary>
 Creates an async operation that starts the given job on the specified
 scheduler and then waits until the started job finishes.  See also:
 `Job.Scheduler`, `Async.Global.ofJob`.
</summary>
</member>
<member name="M:Hopac.Extensions.Async.toAltOn``1(System.Threading.SynchronizationContext,Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Creates an alternative that, when instantiated, posts the given async
 operation to the specified synchronization context for execution and
 then becomes enabled once the operation finishes.  Furthermore, in case
 the alternative is not committed to, the async operation is cancelled.
 As a special case, `toAltOn null xA` is equivalent to `toAlt xA`.  See
 also: `toJob`, `toJobOn`.
</summary>
</member>
<member name="M:Hopac.Extensions.Async.toAlt``1(Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Creates an alternative that, when instantiated, starts the given async
 operation and then becomes enabled once the operation finishes.
 Furthermore, in case the alternative is not committed to, the async
 operation is cancelled.  See also: `toJob`, `toJobOn`, `toAltOn`.
</summary>
</member>
<member name="M:Hopac.Extensions.Async.toJobOn``1(System.Threading.SynchronizationContext,Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Creates a job that posts the given async operation to the specified
 synchronization context for execution and then waits until the operation
 finishes.  As a special case, `toJobOn null xA` is equivalent to `toJob
 xA`.  See also: `toAlt`, `toAltOn`.
</summary>
</member>
<member name="M:Hopac.Extensions.Async.toJob``1(Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Creates a job that starts the given async operation and then waits until
 the operation finishes.  See also: `toJobOn`, `toAlt`, `toAltOn`.
</summary>
</member>
<member name="M:Hopac.Extensions.Async.Global.onMain">
<summary>
 Creates a builder for running an async workflow on the main
 synchronization context and interoperating with the Hopac global
 scheduler.  The application must call `Hopac.Extensions.Async.setMain`
 to configure Hopac with the main synchronization context.
</summary>
</member>
<member name="M:Hopac.Extensions.Async.Global.ofJob``1(Hopac.Job{``0})">
<summary>
 Creates an async operation that starts the given job on the global
 scheduler and then waits until the started job finishes.  See also:
 `Async.ofJobOn`.
</summary>
</member>
<member name="T:Hopac.Extensions.Async.Global">
<summary>
 Operations on the global scheduler.
</summary>
</member>
<member name="T:Hopac.Extensions.Async">
<summary>
 Operations for interfacing F# async operations with jobs.
</summary>
</member>
<member name="M:Hopac.Extensions.Seq.foldJob``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0,System.Collections.Generic.IEnumerable{``1})">
<summary>
 Sequentially folds the job constructor over the given sequence and
 returns the result of the fold.
</summary>
</member>
<member name="M:Hopac.Extensions.Seq.mapJob``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Sequentially maps the given job constructor to the elements of the
 sequence and returns a list of the results.  See also: `seqCollect`,
 `Seq.Con.mapJob`, `Array.mapJob`.
</summary>
</member>
<member name="M:Hopac.Extensions.Seq.iterJobIgnore``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 `Seq.iterJobIgnore x2yJ xs` is equivalent to `Seq.iterJob (x2yJ &gt;&gt;
 Job.Ignore) xs`.
</summary>
</member>
<member name="M:Hopac.Extensions.Seq.iterJob``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Sequentially iterates the given job constructor over the given sequence.
 See also: `Seq.iterJobIgnore`, `Seq.Con.iterJob`, `seqIgnore`,
 `Array.mapJob`.
</summary>
</member>
<member name="M:Hopac.Extensions.Seq.Con.mapJob``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Iterates the given job constructor over the given sequence, runs the
 constructed jobs as separate concurrent jobs and waits until all of
 the jobs have finished collecting the results into a list.  See also:
 `Seq.mapJob`, `conCollect`.

 Note that this is not optimal for fine-grained parallel execution.
</summary>
</member>
<member name="M:Hopac.Extensions.Seq.Con.iterJobIgnore``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 `Con.iterJobIgnore x2yJ xs` is equivalent to `Con.iterJob (x2yJ &gt;&gt;
 Job.Ignore) xs`.

 Note that this is not optimal for fine-grained parallel execution.
</summary>
</member>
<member name="M:Hopac.Extensions.Seq.Con.iterJob``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Iterates the given job constructor over the given sequence, runs the
 constructed jobs as separate concurrent jobs and waits until all of
 the jobs have finished.  See also: `Con.iterJobIgnore`, `conIgnore`.

 Note that this is not optimal for fine-grained parallel execution.
</summary>
</member>
<member name="T:Hopac.Extensions.Seq.Con">
<summary>
 Operations for processing sequences using concurrent jobs.
</summary>
</member>
<member name="T:Hopac.Extensions.Seq">
<summary>
 Operations for processing sequences with jobs.
</summary>
</member>
<member name="M:Hopac.Extensions.Array.iterJobIgnore``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])">
<summary>
 `Array.iterJobIgnore x2yJ xs` is equivalent to `Array.iterJob (x2yJ &gt;&gt;
 Job.Ignore) xs`.
</summary>
</member>
<member name="M:Hopac.Extensions.Array.iterJob``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])">
<summary>
 Sequentially iterates the given job constructor over the given array.
 `Array.iterJob x2uJ xs` is an optimized version of `Seq.iterJob x2uJ
 xs`.
</summary>
</member>
<member name="M:Hopac.Extensions.Array.mapJob``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])">
<summary>
 Sequentially maps the given job constructor to the elements of the array
 and returns an array of the results.  `Array.mapJob x2yJ xs` is an
 optimized version of `Seq.mapJob x2yJ xs |&gt;&gt; fun ys -&gt; ys.ToArray ()`.
</summary>
</member>
<member name="T:Hopac.Extensions.Array">
<summary>
 Operations for processing arrays with jobs.
</summary>
</member>
<member name="T:Hopac.Extensions">
<summary>
 Extensions to various system modules and types for programming with jobs.
 You can open this module to use the extensions much like as if they were
 part of the existing modules and types.
</summary>
</member>
<member name="M:Hopac.IVar.read``1(Hopac.IVar{``0})">
<summary>
 Creates an alternative that becomes available after the write once
 variable has been written to.
</summary>
</member>
<member name="M:Hopac.IVar.fillFailure``1(Hopac.IVar{``0},System.Exception)">
<summary>
 Creates a job that writes the given exception to the given write once
 variable.  It is an error to write to a single `IVar` more than once.
 This assumption may be used to optimize the implementation and incorrect
 usage leads to undefined behavior.  See also: `&lt;-=!`, `fill`.
</summary>
</member>
<member name="M:Hopac.IVar.tryFill``1(Hopac.IVar{``0},``0)">
<summary>
 Creates a job that tries to write the given value to the given write once
 variable.  No operation takes places and no error is reported in case the
 write once variable has already been written to.
</summary>
</member>
<member name="M:Hopac.IVar.fill``1(Hopac.IVar{``0},``0)">
<summary>
 Creates a job that writes the given value to the given write once
 variable.  It is an error to write to a single write once variable more
 than once.  This assumption may be used to optimize the implementation of
 `fill` and incorrect usage leads to undefined behavior.
</summary>
</member>
<member name="M:Hopac.IVar.create``1">
<summary>
 Creates a job that creates a new write once variable.
</summary>
</member>
<member name="M:Hopac.IVar.Now.get``1(Hopac.IVar{``0})">
<summary>
 Returns the value or raises the failure exception written to the write
 once variable.  It is considered an error if the write once variable has
 not yet been written to.

 This operation is mainly provided for advanced uses of write once
 variables such as when creating more complex data structures that make
 internal use of write once variables.  Using this to poll write once
 variables is not generally a good idea.
</summary>
</member>
<member name="M:Hopac.IVar.Now.isFull``1(Hopac.IVar{``0})">
<summary>
 Returns true iff the given write once variable has already been filled
 (either with a value or with a failure).

 This operation is mainly provided for advanced uses of write once
 variables such as when creating more complex data structures that make
 internal use of write once variables.  Using this to poll write once
 variables is not generally a good idea.
</summary>
</member>
<member name="M:Hopac.IVar.Now.createFailure``1(System.Exception)">
<summary>
 Creates a new write once variable with the given failure exception.
</summary>
</member>
<member name="M:Hopac.IVar.Now.createFull``1(``0)">
<summary>
 Creates a new write once variable with the given value.
</summary>
</member>
<member name="M:Hopac.IVar.Now.create``1">
<summary>
 Creates a new write once variable.
</summary>
</member>
<member name="T:Hopac.IVar.Now">
<summary>
 Immediate or non-workflow operations on write once variables.
</summary>
</member>
<member name="T:Hopac.IVar">
<summary>
 Operations on write once variables.
</summary>
</member>
<member name="M:Hopac.Infixes.op_LessLessMinusPlus``1(Hopac.Mailbox{``0},``0)">
<summary>
 Creates a job that sends the given value to the specified mailbox.  This
 operation never blocks.  `xMb &lt;&lt;-+ x` is equivalent to `Mailbox.send xMb
 x`.
</summary>
</member>
<member name="M:Hopac.Infixes.op_LessLessMinusEquals``1(Hopac.MVar{``0},``0)">
<summary>
 Creates a job that writes the given value to the serialized variable.  It
 is an error to write to a `MVar` that is full.  This assumption may be
 used to optimize the implementation and incorrect usage leads to undefined
 behavior.  `xM &lt;&lt;-= x` is equivalent to `MVar.fill xM x`.
</summary>
</member>
<member name="M:Hopac.Infixes.op_LessMinusEqualsBang``1(Hopac.IVar{``0},System.Exception)">
<summary>
 Creates a job that writes the given exception to the given write once
 variable.  It is an error to write to a single `IVar` more than once.
 This assumption may be used to optimize the implementation and incorrect
 usage leads to undefined behavior.  `xI &lt;-=! e` is equivalent to
 `IVar.fillFailure xI e`.
</summary>
</member>
<member name="M:Hopac.Infixes.op_LessMinusEquals``1(Hopac.IVar{``0},``0)">
<summary>
 Creates a job that writes to the given write once variable.  It is an
 error to write to a single `IVar` more than once.  This assumption may be
 used to optimize the implementation and incorrect usage leads to undefined
 behavior.  `xI &lt;-= x` is equivalent to `IVar.fill xI x`.
</summary>
</member>
<member name="M:Hopac.Infixes.op_LessMinusPlus``1(Hopac.Ch{``0},``0)">
<summary>
 Creates a job that sends a value to another job on the given channel.  A
 send operation is asynchronous.  In other words, a send operation does not
 wait for another job to give the value to.  `xCh &lt;-+ x` is equivalent to
 `Ch.send xCh x`.

 Note that channels have been optimized for synchronous operations; an
 occasional send can be efficient, but when sends are queued, performance
 maybe be significantly worse than with a `Mailbox` optimized for
 buffering.
</summary>
</member>
<member name="M:Hopac.Infixes.op_LessMinusMinus``1(Hopac.Ch{``0},``0)">
<summary>
 Creates an alternative that, at instantiation time, offers to give the
 given value on the given channel, and becomes available when another job
 offers to take the value.  `xCh &lt;-- x` is equivalent to `Ch.give xCh x`.
</summary>
</member>
<member name="T:Hopac.Infixes">
<summary>
 Additional infix operators.  You can open this module to bring all of the
 infix operators into scope.
</summary>
</member>
<member name="M:Hopac.Job.paranoid``1(Hopac.Job{``0})">
<summary>
 Given a job, creates a new job that behaves exactly like the given job,
 except that the new job obviously cannot be directly downcast to the
 underlying type of the given job.  This operation is provided for
 debugging purposes.  You can always break abstractions using reflection.
 See also: `Alt.paranoid`.
</summary>
</member>
<member name="M:Hopac.Job.fromEndBegin``1(Microsoft.FSharp.Core.FSharpFunc{System.IAsyncResult,``0},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.AsyncCallback,System.Object},System.IAsyncResult})">
<summary>
 `fromEndBegin doEnd doBegin` is equivalent to `fromBeginEnd doBegin doEnd`.
</summary>
</member>
<member name="M:Hopac.Job.fromBeginEnd``1(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FSharpFunc{System.IAsyncResult,``0})">
<summary>
 Creates a job that performs the asynchronous operation defined by the
 given pair of begin and end operations.
</summary>
</member>
<member name="M:Hopac.Job.conIgnore``2(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates a job that runs all of the jobs as separate concurrent jobs and
 then waits for all of the jobs to finish.  The results of the jobs are
 ignored.  See also: `conCollect`, `seqIgnore`, `Seq.Con.iterJob`.

 Note that when multiple jobs raise exceptions, then the created job raises
 an `AggregateException`.

 Note that this is not optimal for fine-grained parallel execution.
</summary>
</member>
<member name="M:Hopac.Job.conCollect``2(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates a job that runs all of the jobs as separate concurrent jobs and
 returns a list of the results.  See also: `conIgnore`, `seqCollect`,
 `Seq.Con.mapJob`.

 Note that when multiple jobs raise exceptions, then the created job raises
 an `AggregateException`.

 Note that this is not optimal for fine-grained parallel execution.
</summary>
</member>
<member name="M:Hopac.Job.seqIgnore``2(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates a job that runs all of the jobs in sequence.  The results of the
 jobs are ignored.  See also: `seqCollect`, `conIgnore`, `Seq.iterJob`.
</summary>
</member>
<member name="M:Hopac.Job.seqCollect``2(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates a job that runs all of the jobs in sequence and returns a list of
 the results.  See also: `seqIgnore`, `conCollect`, `Seq.mapJob`.
</summary>
</member>
<member name="M:Hopac.Job.iterateServer``2(``0,Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Creates a job that starts a separate server job that indefinitely iterates
 the given job constructor starting with the given value.  `iterateServer x
 x2xJ` is equivalent to `iterate x x2xJ |&gt; server`.
</summary>
</member>
<member name="M:Hopac.Job.foreverServer(Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Creates a job that starts a separate server job that repeats the given job
 indefinitely.  `foreverServer xJ` is equivalent to `forever xJ |&gt; server`.
</summary>
</member>
<member name="M:Hopac.Job.iterate``3(``0,Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Creates a job that indefinitely iterates the given job constructor
 starting with the given value.  See also: `iterateServer`, `forever`.
</summary>
</member>
<member name="M:Hopac.Job.foreverIgnore``2(Hopac.Job{``0})">
<summary>
 `foreverIgnore xJ` is equivalent to `Job.Ignore xJ |&gt; forever`.
</summary>
</member>
<member name="M:Hopac.Job.forever``1(Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Creates a job that repeats the given job indefinitely.  See also:
 `foreverServer`, `iterate`.
</summary>
</member>
<member name="M:Hopac.Job.whenDo(System.Boolean,Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 `whenDo b uJ` is equivalent to `if b then uJ else Job.unit ()`.
</summary>
</member>
<member name="M:Hopac.Job.whileDoIgnore``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Boolean},Hopac.Job{``0})">
<summary>
 `whileDoIgnore u2b xJ` creates a job that sequentially executes the `xJ`
 job as long as `u2b ()` returns `true`.  `whileDoIgnore u2b xJ` is
 equivalent to `Job.Ignore xJ |&gt; whileDo u2b`.
</summary>
</member>
<member name="M:Hopac.Job.whileDoDelay``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Boolean},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 `whileDoDelay u2b u2xJ` creates a job that sequentially constructs a job
 with `u2xJ` and executes it as long as `u2b ()` returns `true`.
</summary>
</member>
<member name="M:Hopac.Job.whileDo(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Boolean},Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 `whileDo u2b uJ` creates a job that sequentially executes the `uJ` job as
 long as `u2b ()` returns `true`.  See also: `whileDoDelay`.
</summary>
</member>
<member name="M:Hopac.Job.forDownToIgnore``2(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
<summary>
 `forDownToIgnore hi lo i2xJ` is equivalent to `forDownTo hi lo (i2xJ &gt;&gt;
 Job.Ignore)`.
</summary>
</member>
<member name="M:Hopac.Job.forDownTo``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
<summary>
 `forDownTo hi lo i2uJ` creates a job that sequentially iterates from `hi`
 to `lo` (inclusive) and calls the given function to construct jobs that
 will be executed.
</summary>
</member>
<member name="M:Hopac.Job.forUpToIgnore``2(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
<summary>
 `forUpToIgnore lo hi i2xJ` is equivalent to `forUpTo lo hi (i2xJ &gt;&gt;
 Job.Ignore)`.
</summary>
</member>
<member name="M:Hopac.Job.forUpTo``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
<summary>
 `forUpTo lo hi i2uJ` creates a job that sequentially iterates from `lo` to
 `hi` (inclusive) and calls the given function to construct jobs that will
 be executed.
</summary>
</member>
<member name="M:Hopac.Job.forNIgnore``1(System.Int32,Hopac.Job{``0})">
<summary>
 `forNIgnore n xJ` is equivalent to `Job.Ignore xJ |&gt; forN n`.
</summary>
</member>
<member name="M:Hopac.Job.forN(System.Int32,Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Creates a job that runs the given job sequentially the given number of
 times.
</summary>
</member>
<member name="M:Hopac.Job.catch``1(Hopac.Job{``0})">
<summary>
 Creates a job that runs the given job and results in either the ordinary
 result of the job or the exception raised by the job.
</summary>
</member>
<member name="M:Hopac.Job.usingAsync``3(``0,Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Implements an experimental `use` like construct for asynchronously
 disposable resources.  The `DisposeAsync` method of the asynchronously
 disposable resource is called to construct a job that is later used to
 dispose the resource after the constructed job returns.  See also:
 `abort`, `using`.
</summary>
</member>
<member name="M:Hopac.Job.using``3(``0,Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Implements the `use` construct for jobs.  The `Dispose` method of the
 given disposable object is called after running the job constructed with
 the disposable object.  See also: `abort`, `usingAsync`.
</summary>
</member>
<member name="M:Hopac.Job.tryFinallyJobDelay``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Implements a variation of the `try-finally` exception handling construct
 for jobs.  The given action, specified as a job, is executed after the job
 has been run, whether it fails or completes successfully.
</summary>
</member>
<member name="M:Hopac.Job.tryFinallyJob``1(Hopac.Job{``0},Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Implements a variation of the `try-finally` exception handling construct
 for jobs.  The given action, specified as a job, is executed after the job
 has been run, whether it fails or completes successfully.
</summary>
</member>
<member name="M:Hopac.Job.tryFinallyFunDelay``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Implements a variation of the `try-finally` exception handling construct
 for jobs.  The given action, specified as a function, is executed after
 the job has been run, whether it fails or completes successfully.
</summary>
</member>
<member name="M:Hopac.Job.tryFinallyFun``1(Hopac.Job{``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Implements a variation of the `try-finally` exception handling construct
 for jobs.  The given action, specified as a function, is executed after
 the job has been run, whether it fails or completes successfully.
</summary>
</member>
<member name="M:Hopac.Job.tryWithDelay``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FSharpFunc{System.Exception,``2})">
<summary>
 Implements the try-with exception handling construct for jobs.
</summary>
</member>
<member name="M:Hopac.Job.tryWith``2(Hopac.Job{``0},Microsoft.FSharp.Core.FSharpFunc{System.Exception,``1})">
<summary>
 Implements the try-with exception handling construct for jobs.
</summary>
</member>
<member name="M:Hopac.Job.tryInDelay``5(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FSharpFunc{``1,``2},Microsoft.FSharp.Core.FSharpFunc{System.Exception,``4})">
<summary>
 Implements the `try-in-unless` exception handling construct for jobs.
 Both of the continuation jobs `&apos;x -&gt; Job&lt;&apos;y&gt;`, for success, and `exn -&gt;
 Job&lt;&apos;y&gt;`, for failure, are invoked from a tail position.  `tryInDelay u2xJ
 x2yJ e2yJ` is equivalent to `tryIn (delay u2xJ) x2yJ e2yJ`.
</summary>
</member>
<member name="M:Hopac.Job.tryIn``4(Hopac.Job{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{System.Exception,``3})">
<summary>
 Implements the `try-in-unless` exception handling construct for jobs.
 Both of the continuation jobs `&apos;x -&gt; Job&lt;&apos;y&gt;`, for success, and `exn -&gt;
 Job&lt;&apos;y&gt;`, for failure, are invoked from a tail position.  See also:
 `tryInDelay`.
</summary>
</member>
<member name="M:Hopac.Job.raises``1(System.Exception)">
<summary>
 Creates a job that has the effect of raising the specified exception.
 `raises e` is equivalent to `Job.delayWith raise e`.
</summary>
</member>
<member name="M:Hopac.Job.abort``1">
<summary>
 Creates a job that immediately terminates the current job.  See also:
 `startWithFinalizer`.
</summary>
</member>
<member name="M:Hopac.Job.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Job{``0})">
<summary>
 Creates a job that runs the given job and maps the result of the job with
 the given function.  This is the same as `|&gt;&gt;` with the arguments flipped.
</summary>
</member>
<member name="M:Hopac.Job.join``2(Hopac.Job{``0})">
<summary>
 `join xJJ` is equivalent to `bind id xJJ`.
</summary>
</member>
<member name="M:Hopac.Job.bind``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Job{``0})">
<summary>
 Creates a job that first runs the given job and then passes the result of
 that job to the given function to build another job which will then be
 run.  This is the same as `&gt;&gt;=` with the arguments flipped.
</summary>
</member>
<member name="M:Hopac.Job.result``1(``0)">
<summary>
 Creates a job with the given result.  See also: `lift`, `thunk`, `unit`.
</summary>
</member>
<member name="M:Hopac.Job.unit">
<summary>
 Returns a job that does nothing and returns `()`.  `unit ()` is an
 optimized version of `result ()`.
</summary>
</member>
<member name="M:Hopac.Job.Ignore``1(Hopac.Job{``0})">
<summary>
 Creates a job like the given job except that the result of the job will be
 `()`.  `Ignore xJ` is equivalent to `xJ |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:Hopac.Job.thunk``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Creates a job that invokes the given thunk to compute the result of the
 job.  `thunk u2x` is equivalent to `result () |&gt;&gt; u2x`.
</summary>
</member>
<member name="M:Hopac.Job.lift``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0)">
<summary>
 Creates a job that calls the given function with the given value to
 compute the result of the job.  `lift x2y x` is equivalent to `result x
 |&gt;&gt; x2y`.  Note that `x2y x |&gt; result` is not the same.
</summary>
</member>
<member name="M:Hopac.Job.delayWith``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0)">
<summary>
 Creates a job that calls the given function with the given value to build
 a job that will then be run.  `delayWith x2yJ x` is equivalent to `result
 x &gt;&gt;= x2yJ`.
</summary>
</member>
<member name="M:Hopac.Job.delay``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Creates a job that calls the given function to build a job that will then
 be run.  `delay u2xJ` is equivalent to `result () &gt;&gt;= u2xJ`.
</summary>
</member>
<member name="M:Hopac.Job.startWithFinalizerIgnore``1(Hopac.Job{Microsoft.FSharp.Core.Unit},Hopac.Job{``0})">
<summary>
 Creates a job that immediately starts running the given job as a separate
 concurrent job like `start`, but also attaches a finalizer to the started
 job.  `startWithFinalizerIgnore finalizerJ xJ` is equivalent to
 `Job.Ignore xJ |&gt; startWithFinalizer finalizerJ`.
</summary>
</member>
<member name="M:Hopac.Job.startWithFinalizer(Hopac.Job{Microsoft.FSharp.Core.Unit},Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Creates a job that immediately starts running the given job as a separate
 concurrent job like `start`, but also attaches a finalizer to the started
 job.  The finalizer job is started as a separate job in case the started
 job does not return succesfully or raise an exception and is garbage
 collected.  If the job either returns normally or raises an exception, the
 finalizer job is not started.  See also: `Proc`.
</summary>
</member>
<member name="M:Hopac.Job.server(Hopac.Job{Hopac.Void})">
<summary>
 Creates a job that immediately starts running the given job as a separate
 concurrent job like `start`, but the given job is known never to return
 normally, so the job can be spawned in an even more lightweight manner.
</summary>
</member>
<member name="M:Hopac.Job.queueIgnore``1(Hopac.Job{``0})">
<summary>
 Creates a job that schedules the given job to be run as a separate
 concurrent job.  `queueIgnore xJ` is equivalent to `Job.Ignore xJ |&gt;
 queue`.
</summary>
</member>
<member name="M:Hopac.Job.queue(Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Creates a job that schedules the given job to be run as a separate
 concurrent job.  Use `Promise.queue` if you need to be able to get the
 result.  See also: `Proc.queue`.
</summary>
</member>
<member name="M:Hopac.Job.startIgnore``1(Hopac.Job{``0})">
<summary>
 Creates a job that immediately starts running the given job as a separate
 concurrent job.  `startIgnore xJ` is equivalent to `Job.Ignore xJ |&gt;
 start`.
</summary>
</member>
<member name="M:Hopac.Job.start(Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Creates a job that immediately starts running the given job as a separate
 concurrent job.  Use `Promise.start` if you need to be able to get the
 result.  Use `Job.server` if the job never returns normally.  See also:
 `Job.queue`, `Proc.start`.
</summary>
</member>
<member name="M:Hopac.Job.Random.get">
<summary>
 Returns a job that generates a pseudo random 64-bit unsigned integer.
 `get ()` is equivalent to `bind result`.
</summary>
</member>
<member name="M:Hopac.Job.Random.map``1(Microsoft.FSharp.Core.FSharpFunc{System.UInt64,``0})">
<summary>
 `map r2x` is equivalent to `bind (r2x &gt;&gt; result)`.
</summary>
</member>
<member name="M:Hopac.Job.Random.bind``2(Microsoft.FSharp.Core.FSharpFunc{System.UInt64,``0})">
<summary>
 `bind r2xJ` creates a job that calls the given job constructor with a
 pseudo random 64-bit unsigned integer.
</summary>
</member>
<member name="T:Hopac.Job.Random">
<summary>
 Operations on the built-in pseudo random number generator (PRNG) of Hopac.
</summary>
</member>
<member name="M:Hopac.Job.Scheduler.switchToWorker">
<summary>
 Returns a job that ensures that the immediately following operation will
 be executed on a Hopac worker thread.
</summary>
</member>
<member name="M:Hopac.Job.Scheduler.get">
<summary>
 Returns a job that returns the scheduler under which the job is being
 run.  `get ()` is equivalent to `bind result`.
</summary>
</member>
<member name="M:Hopac.Job.Scheduler.bind``2(Microsoft.FSharp.Core.FSharpFunc{Hopac.Scheduler,``0})">
<summary>
 `bind s2xJ` creates a job that calls the given job constructor with the
 scheduler under which the job is being executed.  `bind` allows
 interfacing Hopac with existing asynchronous operations that do not fall
 into a pattern that is already supported explicitly.
</summary>
</member>
<member name="T:Hopac.Job.Scheduler">
<summary>
 Operations for dealing with the scheduler.
</summary>
</member>
<member name="M:Hopac.Job.Infixes.op_LessMultiplyGreater``2(Hopac.Job{``0},Hopac.Job{``1})">
<summary>
 Creates a job that either runs the given jobs sequentially, like `&lt;&amp;&gt;`,
 or as two separate parallel jobs and returns a pair of their results.

 Note that when the jobs are run in parallel and both of them raise an
 exception then the created job raises an `AggregateException`.
</summary>
</member>
<member name="M:Hopac.Job.Infixes.op_LessAmpGreater``2(Hopac.Job{``0},Hopac.Job{``1})">
<summary>
 Creates a job that runs the given two jobs and then returns a pair of
 their results.  `xJ &lt;&amp;&gt; yJ` is equivalent to `xJ &gt;&gt;= fun x -&gt; yJ &gt;&gt;= fun
 y -&gt; result (x, y)`.
</summary>
</member>
<member name="M:Hopac.Job.Infixes.op_GreaterGreaterBang``2(Hopac.Job{``0},System.Exception)">
<summary>
 Creates a job that runs the given job and then raises the given
 exception.  `xJ &gt;&gt;! e` is equivalent to `xJ &gt;&gt;= fun _ -&gt; raise e`.
</summary>
</member>
<member name="M:Hopac.Job.Infixes.op_GreaterGreaterPercent``2(Hopac.Job{``0},``1)">
<summary>
 Creates a job that runs the given job and then returns the given value.
 `xJ &gt;&gt;% y` is an optimized version of `xJ &gt;&gt;= fun _ -&gt; result y`.
</summary>
</member>
<member name="M:Hopac.Job.Infixes.op_BarGreaterGreater``2(Hopac.Job{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Creates a job that runs the given job and maps the result of the job
 with the given function.  `xJ |&gt;&gt; x2y` is an optimized version of `xJ
 &gt;&gt;= (x2y &gt;&gt; result)`.  This is the same as `map` with the arguments
 flipped.
</summary>
</member>
<member name="M:Hopac.Job.Infixes.op_DotGreaterGreater``2(Hopac.Job{``0},Hopac.Job{``1})">
<summary>
 Creates a job that runs the given two jobs and returns the result of the
 first job.  `xJ .&gt;&gt; yJ` is equivalent to `xJ &gt;&gt;= fun x -&gt; yJ &gt;&gt;% x`.
</summary>
</member>
<member name="M:Hopac.Job.Infixes.op_GreaterGreaterDot``2(Hopac.Job{``0},Hopac.Job{``1})">
<summary>
 Creates a job that runs the given two jobs and returns the result of the
 second job.  `xJ &gt;&gt;. yJ` is equivalent to `xJ &gt;&gt;= fun _ -&gt; yJ`.
</summary>
</member>
<member name="M:Hopac.Job.Infixes.op_GreaterEqualsGreater``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3},``0)">
<summary>
 Creates a job that is the composition of the given two jobs.  `(x2yJ &gt;=&gt;
 y2zJ) x` is equivalent to `x2yJ x &gt;&gt;= y2zJ` and is much like the `&gt;&gt;`
 operator on ordinary functions.
</summary>
</member>
<member name="M:Hopac.Job.Infixes.op_GreaterGreaterEquals``3(Hopac.Job{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Creates a job that first runs the given job and then passes the result
 of that job to the given function to build another job which will then
 be run.  This is the same as `bind` with the arguments flipped.
</summary>
</member>
<member name="T:Hopac.Job.Infixes">
<summary>
 Infix operators on jobs.  You can open this module to bring all of the
 infix operators into scope.
</summary>
</member>
<member name="M:Hopac.Job.Global.run``1(Hopac.Job{``0})">
<summary>
 Starts running the given job on the global scheduler and then blocks the
 current thread waiting for the job to either return successfully or
 fail.
</summary>
</member>
<member name="M:Hopac.Job.Global.server(Hopac.Job{Hopac.Void})">
<summary>
 Like `Job.Global.start`, but the given job is known never to return
 normally, so the job can be spawned in an even more lightweight manner.
</summary>
</member>
<member name="M:Hopac.Job.Global.queueIgnore``1(Hopac.Job{``0})">
<summary>
 Queues the job for execution on the global scheduler.  `queueIgnore xJ`
 is equivalent to `Job.Ignore xJ |&gt; queue`.
</summary>
</member>
<member name="M:Hopac.Job.Global.queue(Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Queues the job for execution on the global scheduler.  See also:
 `start`, `server`.
</summary>
</member>
<member name="M:Hopac.Job.Global.startIgnore``1(Hopac.Job{``0})">
<summary>
 Starts running the given job on the global scheduler, but does not wait
 for the job to finish.  `startIgnore xJ` is equivalent to `Job.Ignore xJ
 |&gt; start`.
</summary>
</member>
<member name="M:Hopac.Job.Global.start(Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Starts running the given job on the global scheduler, but does not wait
 for the job to finish.  See also: `queue`, `server`.
</summary>
</member>
<member name="M:Hopac.Job.Global.startWithActions``1(Microsoft.FSharp.Core.FSharpFunc{System.Exception,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Hopac.Job{``0})">
<summary>
 Starts running the given job on the global scheduler, but does not wait
 for the job to finish.  Upon the failure or success of the job, one of
 the given actions is called once.
</summary>
</member>
<member name="T:Hopac.Job.Global">
<summary>
 Operations on the global scheduler.
</summary>
</member>
<member name="T:Hopac.Job">
<summary>
 Operations on jobs.
</summary>
</member>
<member name="M:Hopac.Latch.await(Hopac.Latch)">
<summary>
 Returns an alternative that becomes available once the latch opens.
</summary>
</member>
<member name="M:Hopac.Latch.decrement(Hopac.Latch)">
<summary>
 Returns a job that explicitly decrements the counter of the latch.  When
 the counter reaches `0`, the latch becomes open and operations awaiting
 the latch are resumed.
</summary>
</member>
<member name="M:Hopac.Latch.queueAsPromise``1(Hopac.Latch,Hopac.Job{``0})">
<summary>
 Creates a job that queues the given job to run as a separate concurrent
 job and holds the latch until the queued job either returns or fails with
 an exception.  A promise is returned for observing the result or failure
 of the queued job.
</summary>
</member>
<member name="M:Hopac.Latch.queue(Hopac.Latch,Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Creates a job that queues the given job to run as a separate concurrent
 job and holds the latch until the queued job either returns or fails with
 an exception.  See also `Latch.queueAsAlt`.
</summary>
</member>
<member name="M:Hopac.Latch.holding``1(Hopac.Latch,Hopac.Job{``0})">
<summary>
 Creates a job that runs the given job holding the specified latch.  Note
 that the latch is only held while the given job is being run.  See also
 `Latch.queue`.
</summary>
</member>
<member name="M:Hopac.Latch.within``2(Microsoft.FSharp.Core.FSharpFunc{Hopac.Latch,``0})">
<summary>
 Creates a job that creates a new latch, passes it to the given function to
 create a new job to run and then awaits for the latch to open.
</summary>
</member>
<member name="M:Hopac.Latch.Now.increment(Hopac.Latch)">
<summary>
 Increments the counter of the latch.
</summary>
</member>
<member name="M:Hopac.Latch.Now.create(System.Int32)">
<summary>
 Creates a new latch with the specified initial count.
</summary>
</member>
<member name="T:Hopac.Latch.Now">
<summary>
 Immediate operations on latches.
</summary>
</member>
<member name="T:Hopac.Latch">
<summary>
 Operations on latches.
</summary>
</member>
<member name="M:Hopac.Lock.duringJob``1(Hopac.Lock,Hopac.Job{``0})">
<summary>
 Creates a job that runs the given job so that the lock is held during the
 execution of the given job.
</summary>
</member>
<member name="M:Hopac.Lock.duringFun``1(Hopac.Lock,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Creates a job that calls the given function so that the lock is held
 during the execution of the function.
</summary>
</member>
<member name="M:Hopac.Lock.create">
<summary>
 Creates a job that creates a new mutual exclusion lock.
</summary>
</member>
<member name="M:Hopac.Lock.Now.create">
<summary>
 Creates a new lock.
</summary>
</member>
<member name="T:Hopac.Lock.Now">
<summary>
 Immediate or non-workflow operations on locks.
</summary>
</member>
<member name="T:Hopac.Lock">
<summary>
 Operations on mutual exclusion locks.
</summary>
</member>
<member name="M:Hopac.MVar.take``1(Hopac.MVar{``0})">
<summary>
 Creates an alternative that becomes available when the variable contains a
 value and, if committed to, takes the value from the variable.
</summary>
</member>
<member name="M:Hopac.MVar.read``1(Hopac.MVar{``0})">
<summary>
 Creates an alternative that becomes available when the variable contains a
 value and, if committed to, read the value from the variable.
</summary>
</member>
<member name="M:Hopac.MVar.modifyJob``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.MVar{``0})">
<summary>
 Creates an alternative that takes the value of the serialized variable and
 then fills the variable with the result of performing the given job.

 Note that this operation is not atomic as such.  However, it is a common
 programming pattern to make it so that only the job that has emptied an
 `MVar` by taking a value from it is allowed to fill the `MVar`.  Such an
 access pattern makes operations on the `MVar` appear as atomic.
</summary>
</member>
<member name="M:Hopac.MVar.modifyFun``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{``0,``1}},Hopac.MVar{``0})">
<summary>
 Creates an alternative that takes the value of the serialized variable and
 then fills the variable with the result of performing the given function.

 Note that this operation is not atomic as such.  However, it is a common
 programming pattern to make it so that only the job that has emptied an
 `MVar` by taking a value from it is allowed to fill the `MVar`.  Such an
 access pattern makes operations on the `MVar` appear as atomic.
</summary>
</member>
<member name="M:Hopac.MVar.fill``1(Hopac.MVar{``0},``0)">
<summary>
 Creates a job that writes the given value to the serialized variable.  It
 is an error to write to a `MVar` that is full.  This assumption may be
 used to optimize the implementation and incorrect usage leads to undefined
 behavior.  See also: `&lt;&lt;-=`.
</summary>
</member>
<member name="M:Hopac.MVar.createFull``1(``0)">
<summary>
 Creates a job that creates a new serialized variable that initially
 contains the given value.
</summary>
</member>
<member name="M:Hopac.MVar.create``1">
<summary>
 Creates a job that creates a new serialized variable that is initially
 empty.
</summary>
</member>
<member name="M:Hopac.MVar.Now.createFull``1(``0)">
<summary>
 Creates a new serialized variable that initially contains the given
 value.
</summary>
</member>
<member name="M:Hopac.MVar.Now.create``1">
<summary>
 Creates a new serialized variable that is initially empty.
</summary>
</member>
<member name="T:Hopac.MVar.Now">
<summary>
 Immediate or non-workflow operations on serialized variables.
</summary>
</member>
<member name="T:Hopac.MVar">
<summary>
 Operations on serialized variables.
</summary>
</member>
<member name="M:Hopac.Mailbox.take``1(Hopac.Mailbox{``0})">
<summary>
 Creates an alternative that becomes available when the mailbox contains at
 least one value and, if committed to, takes a value from the mailbox.
</summary>
</member>
<member name="M:Hopac.Mailbox.send``1(Hopac.Mailbox{``0},``0)">
<summary>
 Creates a job that sends the given value to the specified mailbox.  This
 operation never blocks.  See also: `&lt;&lt;-+`.
</summary>
</member>
<member name="M:Hopac.Mailbox.create``1">
<summary>
 Creates a job that creates a new mailbox.
</summary>
</member>
<member name="M:Hopac.Mailbox.Global.send``1(Hopac.Mailbox{``0},``0)">
<summary>
 Sends the given value to the specified mailbox.  `Mailbox.Global.send
 xMb x` is equivalent to `Mailbox.send xMb x |&gt; TopLevel.start`.

 Note that using this function in a job workflow is not optimal and you
 should use `Mailbox.send` instead.
</summary>
</member>
<member name="T:Hopac.Mailbox.Global">
<summary>
 Operations bound to the global scheduler.
</summary>
</member>
<member name="M:Hopac.Mailbox.Now.create``1">
<summary>
 Creates a new mailbox.
</summary>
</member>
<member name="T:Hopac.Mailbox.Now">
<summary>
 Immediate or non-workflow operations on buffered mailboxes.
</summary>
</member>
<member name="T:Hopac.Mailbox">
<summary>
 Operations on buffered mailboxes.
</summary>
</member>
<member name="M:Hopac.Proc.join(Hopac.Proc)">
<summary>
 Returns an alternative that becomes available once the process is known to
 have been terminated for any reason.
</summary>
</member>
<member name="M:Hopac.Proc.self">
<summary>
 Returns a job that returns the current process.
</summary>
</member>
<member name="M:Hopac.Proc.queueIgnore``1(Hopac.Job{``0})">
<summary>
 Creates a job that queues a new process.  `queueIgnore xJ` is equivalent
 to `Job.Ignore xJ |&gt; queue`.
</summary>
</member>
<member name="M:Hopac.Proc.queue(Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Creates a job that queues a new process.  See also: `start`, `Job.queue`.
</summary>
</member>
<member name="M:Hopac.Proc.startIgnore``1(Hopac.Job{``0})">
<summary>
 Creates a job that starts a new process.  `startIgnore xJ` is equivalent
 to `Job.Ignore xJ |&gt; start`.
</summary>
</member>
<member name="M:Hopac.Proc.start(Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Creates a job that starts a new process.  See also: `queue`, `Job.start`.
</summary>
</member>
<member name="T:Hopac.Proc">
<summary>
 Operations on processes.
</summary>
</member>
<member name="M:Hopac.Promise.read``1(Hopac.Promise{``0})">
<summary>
 Creates an alternative for reading the promise.  If the promise was
 delayed, it is started as a separate job.
</summary>
</member>
<member name="M:Hopac.Promise.queue``1(Hopac.Job{``0})">
<summary>
 Creates a job that creates a promise, whose value is computed with the
 given job, which is scheduled to be run as a separate concurrent job.  See
 also: `start`, `Job.queue`.
</summary>
</member>
<member name="M:Hopac.Promise.start``1(Hopac.Job{``0})">
<summary>
 Creates a job that creates a promise, whose value is computed with the
 given job, which is immediately started to run as a separate concurrent
 job.  See also: `queue`, `Job.queue`.
</summary>
</member>
<member name="M:Hopac.Promise.Infixes.op_GreaterGreaterBangMultiply``2(Hopac.Job{``0},System.Exception)">
<summary>
 A memoizing version of `&gt;&gt;!`.
</summary>
</member>
<member name="M:Hopac.Promise.Infixes.op_GreaterGreaterPercentMultiply``2(Hopac.Job{``0},``1)">
<summary>
 A memoizing version of `&gt;&gt;%`.
</summary>
</member>
<member name="M:Hopac.Promise.Infixes.op_BarGreaterGreaterMultiply``2(Hopac.Job{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 A memoizing version of `|&gt;&gt;`.
</summary>
</member>
<member name="M:Hopac.Promise.Infixes.op_DotGreaterGreaterMultiply``2(Hopac.Job{``0},Hopac.Job{``1})">
<summary>
 A memoizing version of `.&gt;&gt;`.
</summary>
</member>
<member name="M:Hopac.Promise.Infixes.op_GreaterGreaterDotMultiply``2(Hopac.Job{``0},Hopac.Job{``1})">
<summary>
 A memoizing version of `&gt;&gt;.`.
</summary>
</member>
<member name="M:Hopac.Promise.Infixes.op_GreaterGreaterEqualsMultiply``3(Hopac.Job{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 A memoizing version of `&gt;&gt;=`.
</summary>
</member>
<member name="M:Hopac.Promise.Infixes.op_LessBarGreaterMultiply``1(Hopac.Alt{``0},Hopac.Alt{``0})">
<summary>
 A memoizing version of `&lt;|&gt;?`.
</summary>
</member>
<member name="T:Hopac.Promise.Infixes">
<summary>
 Infix operators on promises.  You can open this module to bring all of
 the infix operators into scope.
</summary>
</member>
<member name="M:Hopac.Promise.Now.get``1(Hopac.Promise{``0})">
<summary>
 Returns the value or raises the failure exception that the promise has
 been fulfilled with.  It is considered an error if the promise has not
 yet been fulfilled.

 This operation is mainly provided for advanced uses of promises such as
 when creating more complex data structures that make internal use of
 promises.  Using this to poll promises is not generally a good idea.
</summary>
</member>
<member name="M:Hopac.Promise.Now.isFulfilled``1(Hopac.Promise{``0})">
<summary>
 Returns true iff the given promise has already been fulfilled (either
 with a value or with a failure).

 This operation is mainly provided for advanced uses of promises such as
 when creating more complex data structures that make internal use of
 promises.  Using this to poll promises is not generally a good idea.
</summary>
</member>
<member name="M:Hopac.Promise.Now.never``1">
<summary>
 Creates a promise that will never be fulfilled.
</summary>
</member>
<member name="M:Hopac.Promise.Now.withFailure``1(System.Exception)">
<summary>
 Creates a promise with the given failure exception.
</summary>
</member>
<member name="M:Hopac.Promise.Now.withValue``1(``0)">
<summary>
 Creates a promise with the given value.
</summary>
</member>
<member name="M:Hopac.Promise.Now.delay``1(Hopac.Job{``0})">
<summary>
 Creates a promise whose value is computed lazily with the given job when
 an attempt is made to read the promise.  Although the job is not started
 immediately, the effect is that the delayed job will be run as a
 separate job, which means it is possible to communicate with it as long
 the delayed job is started before trying to communicate with it.
</summary>
</member>
<member name="T:Hopac.Promise.Now">
<summary>
 Immediate or non-workflow operations on promises.
</summary>
</member>
<member name="T:Hopac.Promise">
<summary>
 Operations on promises.
</summary>
</member>
<member name="P:Hopac.Scheduler.Create.TopLevelHandler">
<summary>
 Specifies the top level exception handler job constructor of the
 scheduler.  When a job fails with an otherwise unhandled exception,
 the job is killed and a new job is constructed with the top level
 handler constructor and then started.  To avoid infinite loops, in
 case the top level handler job raises exceptions, it is simply killed
 after printing a message to the console.  The default top level
 handler simply prints out a message to the console.
</summary>
</member>
<member name="P:Hopac.Scheduler.Create.NumWorkers">
<summary>
 Number of worker threads.  Using more than
 `Environment.ProcessorCount` is not optimal and may, in some cases,
 significantly reduce performance.  The default is
 `Environment.ProcessorCount`.
</summary>
</member>
<member name="P:Hopac.Scheduler.Create.MaxStackSize">
<summary>
 Specifies the maximum stack size for worker threads.  The default
 is to use the default maximum stack size of the `Thread` class.
</summary>
</member>
<member name="P:Hopac.Scheduler.Create.IdleHandler">
<summary>
 Specifies the idle handler for workers.  The worker idle handler is
 run whenever an individual worker runs out of work.  The idle handler
 must return an integer value that specifies how many milliseconds the
 worker is allowed to sleep.  `Timeout.Infinite` puts the worker into
 sleep until the scheduler explicitly wakes it up.  `0` means that the
 idle handler found some new work and the worker should immediately
 look for it.
</summary>
</member>
<member name="P:Hopac.Scheduler.Create.Foreground">
<summary>
 Specifies whether worker threads are run as background threads or as
 foreground threads.  The default is to run workers as background
 threads.  If you want to run worker threads as foreground threads,
 then you will have to explicitly kill the worker threads.  Using
 foreground threads is probably preferable if your application
 dynamically creates and kills local schedulers to make sure the
 worker threads are properly killed.
</summary>
</member>
<member name="P:Hopac.Scheduler.Create.Def">
<summary>
 Default options.
</summary>
</member>
<member name="T:Hopac.Scheduler.Create">
<summary>
 A record of scheduler configuration options.
</summary>
</member>
<member name="M:Hopac.Scheduler.kill(Hopac.Scheduler)">
<summary>
 Kills the worker threads of the scheduler one-by-one.  This should only be
 used with a local scheduler that is known to be idle.
</summary>
</member>
<member name="M:Hopac.Scheduler.wait(Hopac.Scheduler)">
<summary>
 Waits until the scheduler becomes completely idle.

 Note that for this to make sense, the scheduler should be a local
 scheduler that your program manages explicitly.
</summary>
</member>
<member name="M:Hopac.Scheduler.server(Hopac.Scheduler,Hopac.Job{Hopac.Void})">
<summary>
 Like `Scheduler.start`, but the given job is known never to return
 normally, so the job can be spawned in an even more lightweight manner.
</summary>
</member>
<member name="M:Hopac.Scheduler.queueIgnore``1(Hopac.Scheduler,Hopac.Job{``0})">
<summary>
 `queueIgnore xJ` is equivalent to `Job.Ignore xJ |&gt; queue`.
</summary>
</member>
<member name="M:Hopac.Scheduler.queue(Hopac.Scheduler,Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Queues the given job for execution on the scheduler.

 Note that using this function in a job workflow is not optimal and you
 should use `Job.queue` instead.
</summary>
</member>
<member name="M:Hopac.Scheduler.startIgnore``1(Hopac.Scheduler,Hopac.Job{``0})">
<summary>
 `startIgnore xJ` is equivalent to `Job.Ignore xJ |&gt; start`.
</summary>
</member>
<member name="M:Hopac.Scheduler.start(Hopac.Scheduler,Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Starts running the given job, but does not wait for the job to finish.

 Note that using this function in a job workflow is not optimal and you
 should use `Job.start` instead.
</summary>
</member>
<member name="M:Hopac.Scheduler.startWithActions``1(Hopac.Scheduler,Microsoft.FSharp.Core.FSharpFunc{System.Exception,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Hopac.Job{``0})">
<summary>
 Starts running the given job, but does not wait for the job to finish.
 Upon the failure or success of the job, one of the given actions is called
 once.  See also: `abort`.

 Note that using this function in a job workflow is not optimal and you
 should instead use `Job.start` with desired Job exception handling
 construct (e.g. `Job.tryIn` or `Job.catch`).
</summary>
</member>
<member name="M:Hopac.Scheduler.create(Hopac.Scheduler.Create)">
<summary>
 Creates a new local scheduler.

 Note that a local scheduler does not automatically implement services such
 as the global wall-clock timer.
</summary>
</member>
<member name="M:Hopac.Scheduler.Global.setCreate(Hopac.Scheduler.Create)">
<summary>
 Sets options for creating the global scheduler.  This must be called
 before invoking any Hopac functionality that implicitly creates the
 global scheduler.
</summary>
</member>
<member name="T:Hopac.Scheduler.Global">
<summary>
 Operations on the global scheduler.
</summary>
</member>
<member name="T:Hopac.Scheduler">
<summary>
 Operations on schedulers.  Use of this module requires more intimate
 knowledge of Hopac, but may allow adapting Hopac to special application
 requirements.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Hopac.Stream.Builder">
<summary>
 An experimental generic builder for streams.  The abstract `Plus` and
 `Zero` operations need to be implemented in a derived class.  The
 operations are then used to implement `Bind`, `Combine`, `For` and `While`
 to get a builder with consistent semantics.
</summary>
</member>
<member name="M:Hopac.Stream.KeepPrecedingFuns`2.Next(`1,`0)">
<summary>
 Called to add an element to the current batch.
</summary>
</member>
<member name="M:Hopac.Stream.KeepPrecedingFuns`2.First(`0)">
<summary>
 Called to begin the next batch of elements.
</summary>
</member>
<member name="M:Hopac.Stream.KeepPrecedingFuns`2.#ctor">
<summary>
 Empty constructor.
</summary>
</member>
<member name="T:Hopac.Stream.KeepPrecedingFuns`2">
<summary>
 Functions for collecting elements from a live stream to be lazified.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Hopac.Stream.GenerateFuns`2">
<summary>
 Generator functions for `generateFuns`.
</summary>
</member>
<member name="P:Hopac.Stream.Property`1.Value(`0)">
<summary>
 Allows to get and set the value of a `Property&lt;&apos;x&gt;`.
</summary>
</member>
<member name="P:Hopac.Stream.Property`1.Value">
<summary>
 Allows to get and set the value of a `Property&lt;&apos;x&gt;`.
</summary>
</member>
<member name="M:Hopac.Stream.Property`1.Tap">
<summary>
 Returns the generated stream, including the current value of the
 property, from the point in time when `Tap` is called.
</summary>
</member>
<member name="M:Hopac.Stream.Property`1.#ctor(`0)">
<summary>
 Creates a new property with the specified initial value.
</summary>
</member>
<member name="T:Hopac.Stream.Property`1">
<summary>
 Represents a mutable property, much like a stream variable, that generates
 a stream of values and property change notifications as a side-effect.
</summary>
</member>
<member name="T:Hopac.Stream.MVar`1">
<summary>
 Represents a serialized mutable stream variable that generates a stream of
 values as a side-effect.  The difference between `MVar&lt;&apos;x&gt;` and `Var&lt;&apos;x&gt;`
 is that read-modify-write operations, such as `MVar.updateJob`, are
 serialized, so they effectively appear as atomic, like with the ordinary
 `MVar&lt;&apos;x&gt;`.
</summary>
</member>
<member name="T:Hopac.Stream.Var`1">
<summary>
 Represents a mutable variable, called a stream variable, that generates a
 stream of values as a side-effect.  See also: `MVar&lt;&apos;x&gt;`.
</summary>
</member>
<member name="T:Hopac.Stream.Src`1">
<summary>
 Represents an imperative source of a stream of values called a stream
 source.
</summary>
</member>
<member name="T:Hopac.Stream.Stream`1">
<summary>
 Represents a non-deterministic stream of values called a choice stream.
</summary>
</member>
<member name="T:Hopac.Stream.Cons`1.Nil">
<summary>
 Communicates the end of the stream.
</summary>
</member>
<member name="T:Hopac.Stream.Cons`1.Cons">
<summary>
 Communicates a value and the remainder of the stream.
</summary>
</member>
<member name="T:Hopac.Stream.Cons`1">
<summary>
 Represents a point in a non-deterministic stream of values.
</summary>
</member>
<member name="P:Hopac.Stream.switched">
<summary>
 This builder joins substreams with `switch` to produce a stream with the
 latest results.
</summary>
</member>
<member name="P:Hopac.Stream.ambed">
<summary>
 This builder joins substreams with `amb` to produce a stream with the
 first results.
</summary>
</member>
<member name="P:Hopac.Stream.merged">
<summary>
 This builder joins substreams with `merge` to produce a stream with all
 results in completion order.
</summary>
</member>
<member name="P:Hopac.Stream.appended">
<summary>
 This builder joins substreams with `append` to produce a stream with all
 results in sequential order.
</summary>
</member>
<member name="M:Hopac.Stream.initsMapFun``2(Microsoft.FSharp.Core.FSharpFunc{Hopac.Promise{Hopac.Stream.Cons{``0}},``1},Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 `initsMapFun xs2y xs` is equivalent to `inits xs |&gt; mapFun xs2y`.
</summary>
</member>
<member name="M:Hopac.Stream.inits``1(Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream of all initial segments of the given stream from shortest
 to longest.
</summary>
</member>
<member name="M:Hopac.Stream.init``1(Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream with all the elements of the given stream except the last
 element.  If the stream is closed, a closed stream is returned.  Note that
 `append (init xs) (last xs)` is equivalent to `xs`.
</summary>
</member>
<member name="M:Hopac.Stream.last``1(Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream containing the last element of the given stream.  If the
 given stream is closed, a closed stream is returned.  Note that `append
 (init xs) (last xs)` is equivalent to `xs`.
</summary>
</member>
<member name="M:Hopac.Stream.tailsMapFun``2(Microsoft.FSharp.Core.FSharpFunc{Hopac.Promise{Hopac.Stream.Cons{``0}},``1},Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 `tailsMapFun xs2y xs` is equivalent to `tails xs |&gt; mapFun xs2y`.
</summary>
</member>
<member name="M:Hopac.Stream.tails``1(Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream of all final segments of the given stream from longest to
 shortest.
</summary>
</member>
<member name="M:Hopac.Stream.tail``1(Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream just like the given stream except without the first
 element.  If the given stream is closed, the result stream will also be
 closed.  Note that `append (head xs) (tail xs)` is equivalent to `xs`.
</summary>
</member>
<member name="M:Hopac.Stream.head``1(Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream containing only the first element of the given stream.
 If the given stream is closed, the result stream will also be closed.
 Note that `append (head xs) (tail xs)` is equivalent to `xs`.
</summary>
</member>
<member name="M:Hopac.Stream.count``1(Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a job that computes the length of the given stream.
</summary>
</member>
<member name="M:Hopac.Stream.consume``1(Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 `xs |&gt; consume` is equivalent to `xs |&gt; iter |&gt; queue`.
</summary>
</member>
<member name="M:Hopac.Stream.consumeFun``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 `xs |&gt; consumeFun x2u` is equivalent to `xs |&gt; iterFun x2u |&gt; queue`.
</summary>
</member>
<member name="M:Hopac.Stream.consumeJob``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 `xs |&gt; consumeJob x2uJ` is equivalent to `xs |&gt; iterJob x2uJ |&gt; queue`.
</summary>
</member>
<member name="M:Hopac.Stream.iter``1(Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a job that iterates over all the elements of the given stream.
 `iter xs` is equivalent to `iterFun ignore xs`.  See also: `consume`.
</summary>
</member>
<member name="M:Hopac.Stream.iterFun``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a job that iterates the given function over the given stream.  See
 also: `iterJob`, `consumeFun`.
</summary>
</member>
<member name="M:Hopac.Stream.iterJob``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a job that iterates the given job constructor over the given
 stream.  See also: `consumeJob`.
</summary>
</member>
<member name="M:Hopac.Stream.foldBack``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Hopac.Promise{``1},``2}},Hopac.Promise{Hopac.Stream.Cons{``0}},``2)">
<summary>
 Performs a lazy backwards fold over the stream.  See also: `foldJob`,
 `unfoldJob`.
</summary>
</member>
<member name="M:Hopac.Stream.foldFromFun``2(``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},Hopac.Promise{Hopac.Stream.Cons{``1}})">
<summary>
 `foldFromFun s sx2s xs` is equivalent to `foldFun sx2s s xs` and is often
 syntactically more convenient to use.
</summary>
</member>
<member name="M:Hopac.Stream.foldFromJob``3(``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Hopac.Promise{Hopac.Stream.Cons{``1}})">
<summary>
 `foldFromJob s sx2sJ xs` is equivalent to `foldJob sx2sJ s xs` and is
 often syntactically more convenient to use.
</summary>
</member>
<member name="M:Hopac.Stream.foldFun``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,Hopac.Promise{Hopac.Stream.Cons{``1}})">
<summary>
 Eagerly reduces the given stream using the given function.
</summary>
</member>
<member name="M:Hopac.Stream.foldJob``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0,Hopac.Promise{Hopac.Stream.Cons{``1}})">
<summary>
 Eagerly reduces the given stream using the given job.  See also:
 `foldBack`.
</summary>
</member>
<member name="M:Hopac.Stream.values``1(Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Creates an alternative through which all the values of the stream
 generated after the point at which the alternative has been created can be
 read.  See also: `indefinitely`.
</summary>
</member>
<member name="M:Hopac.Stream.toSeq``1(Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a job that collects all the elements from the stream.  This
 function is provided for testing purposes.
</summary>
</member>
<member name="M:Hopac.Stream.afterTimeSpan(System.TimeSpan)">
<summary>
 Returns a stream that produces an element after the given time span.  Note
 that streams are memoized.
</summary>
</member>
<member name="M:Hopac.Stream.afterDateTimeOffset(System.DateTimeOffset)">
<summary>
 Returns a stream that produces the given date after the given date.
</summary>
</member>
<member name="M:Hopac.Stream.afterDateTimeOffsets(Hopac.Promise{Hopac.Stream.Cons{System.DateTimeOffset}})">
<summary>
 Given a stream of dates, returns a stream that produces the dates after
 the dates.
</summary>
</member>
<member name="M:Hopac.Stream.beforeEach``2(Hopac.Job{``0},Hopac.Promise{Hopac.Stream.Cons{``1}})">
<summary>
 Returns a stream that runs the given job each time a value is requested
 before requesting the next value from the given stream.  If the given job
 fails, the returned stream also fails.  `beforeEach yJ xs` is equivalent
 to `pullOn (indefinitely yJ) xs`.
</summary>
</member>
<member name="M:Hopac.Stream.afterEach``2(Hopac.Job{``0},Hopac.Promise{Hopac.Stream.Cons{``1}})">
<summary>
 Returns a stream that produces the same elements as the given stream, but
 after each element, the given job is used as a delay before a request is
 made to the given stream for the next element.  If the given job fails,
 the returned stream also fails.
</summary>
</member>
<member name="M:Hopac.Stream.delayEach``2(Hopac.Job{``0},Hopac.Promise{Hopac.Stream.Cons{``1}})">
<summary>
 Returns a stream that produces the same elements as the given stream, but
 delays each pulled element using the given job.  If the given job fails,
 the returned stream also fails.  `delayEach yJ xs` is equivalent to
 `zipWithFun (fun x _ -&gt; x) xs (indefinitely yJ)`.  See also: `shift`.
</summary>
</member>
<member name="M:Hopac.Stream.shift``2(Hopac.Job{``0},Hopac.Promise{Hopac.Stream.Cons{``1}})">
<summary>
 Returns a stream that produces the same sequence of elements as the given
 stream, but shifted in time by the given timeout.
</summary>
</member>
<member name="M:Hopac.Stream.combineLatest``2(Hopac.Promise{Hopac.Stream.Cons{``0}},Hopac.Promise{Hopac.Stream.Cons{``1}})">
<summary>
 Returns a stream that produces a new pair of elements whenever either one
 of the given pair of streams produces an element.  If one of the streams
 produces multiple elements before any elements are produced by the other
 stream, then those elements are skipped.  See also: `zip`.
</summary>
</member>
<member name="M:Hopac.Stream.ignoreWhile``2(Hopac.Job{``0},Hopac.Promise{Hopac.Stream.Cons{``1}})">
<summary>
 `ignoreWhile timeout elements` returns a stream that, after getting an
 element, starts a timeout, produces the element and ignores other elements
 until the timeout is signaled.
</summary>
</member>
<member name="M:Hopac.Stream.ignoreUntil``2(Hopac.Job{``0},Hopac.Promise{Hopac.Stream.Cons{``1}})">
<summary>
 `ignoreUntil timeout elements` returns a stream that, after getting an
 element, starts a timeout and produces the last element received when the
 timeout is signaled.
</summary>
</member>
<member name="M:Hopac.Stream.samplesAfter``2(Hopac.Promise{Hopac.Stream.Cons{``0}},Hopac.Promise{Hopac.Stream.Cons{``1}})">
<summary>
 `samplesAfter ticks elements` returns a stream that consumes both ticks
 and elements and produces each element that follows a tick.  Excess
 elements from both streams are skipped.
</summary>
</member>
<member name="M:Hopac.Stream.samplesBefore``2(Hopac.Promise{Hopac.Stream.Cons{``0}},Hopac.Promise{Hopac.Stream.Cons{``1}})">
<summary>
 `samplesBefore ticks elements` returns a stream that consumes both ticks
 and elements and produces each element that precedes a tick.  Excess
 elements from both streams are skipped.
</summary>
</member>
<member name="M:Hopac.Stream.debounce``2(Hopac.Alt{``0},Hopac.Promise{Hopac.Stream.Cons{``1}})">
<summary>
 `debounce timeout elements` returns a stream so that after each element a
 timeout is started and the element is produced if no other elements is
 received before the timeout is signaled.  Note that if the given stream
 produces elements more frequently than the timeout, the returned stream
 never produces any elements.
</summary>
</member>
<member name="M:Hopac.Stream.pullOn``2(Hopac.Promise{Hopac.Stream.Cons{``0}},Hopac.Promise{Hopac.Stream.Cons{``1}})">
<summary>
 Given a stream of ticks and a lazy stream of elements returns a stream of
 elements pulled from the lazy stream based on the ticks.  See also:
 `keepPreceding1`, `keepFollowing1`.
</summary>
</member>
<member name="M:Hopac.Stream.keepFollowing1``1(Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Converts an imperative live stream into a lazy stream by spawning a job to
 eagerly consume (and throw away) elements from the live stream and to
 produce only one element after each pull request.  See also: `pullOn`,
 `keepPreceding1`.
</summary>
</member>
<member name="M:Hopac.Stream.keepPreceding1``1(Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Converts an imperative live stream into a lazy stream by spawning a job to
 eagerly consume (and throw away) elements from the live stream and to
 produce only one most recent element each time when requested.  See also:
 `pullOn`, `keepPreceding`, `keepFollowing1`.
</summary>
</member>
<member name="M:Hopac.Stream.keepPreceding``1(System.Int32,Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Converts a given imperative live stream into a lazy stream of queued
 elements by spawning a job to eagerly consume and queue elements from the
 live stream.  At most `maxCount` most recent elements are kept in a queue
 and after that the oldest elements are thrown away.  See also:
 `keepPreceding1`.
</summary>
</member>
<member name="M:Hopac.Stream.keepPrecedingFuns``2(Hopac.Stream.KeepPrecedingFuns{``0,``1},Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Converts a given imperative live stream into a lazy stream by spawning a
 job to eagerly consume and collect elements from the live stream using the
 given `KeepPrecedingFuns&lt;_, _&gt;` object.
</summary>
</member>
<member name="M:Hopac.Stream.doFinalizeFun``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit},Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream that is just like the given stream except that after
 the returned stream is closed or becomes garbage, a separate job is
 started that calls the given function.  See also: `doFinalizeJob`,
 `onCloseFun`.
</summary>
</member>
<member name="M:Hopac.Stream.doFinalizeJob``1(Hopac.Job{Microsoft.FSharp.Core.Unit},Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream that is just like the given stream except that after
 the returned stream is closed or becomes garbage, the given job is
 started as a separate concurrent job.  See also: `doFinalizeFun`,
 `onCloseJob`.
</summary>
</member>
<member name="M:Hopac.Stream.onCloseFun``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit},Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream that is just like the given stream except that just
 before the returned stream is closed, due to the given stream being
 closed, whether with an error or without, the given function is called.
 In case the function raises an exception, that exception closes the
 returned stream.  See also: `onCloseJob`, `doFinalizeFun`.
</summary>
</member>
<member name="M:Hopac.Stream.onCloseJob``1(Hopac.Job{Microsoft.FSharp.Core.Unit},Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream that is just like the given stream except that just
 before the returned stream is closed, due to the given stream being
 closed, whether with an error or without, the given job is executed.  In
 case the job raises an exception, that exception closes the returned
 stream.  See also: `onCloseFun`, `doFinalizeJob`.
</summary>
</member>
<member name="M:Hopac.Stream.catch``2(Microsoft.FSharp.Core.FSharpFunc{System.Exception,``0},Hopac.Promise{Hopac.Stream.Cons{``1}})">
<summary>
 Returns a stream that produces the same sequence of elements as the given
 stream.  If the given stream fails, a new stream is constructed by calling
 the given function and that stream becomes the remainder of the stream.
</summary>
</member>
<member name="M:Hopac.Stream.takeWhileFun``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Returns the maximal prefix of the given stream of elements that satisfy
 the given predicate given as a function.
</summary>
</member>
<member name="M:Hopac.Stream.takeWhileJob``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Returns the maximal prefix of the given stream of elements that satisfy
 the given predicate given as a job.
</summary>
</member>
<member name="M:Hopac.Stream.skipWhileFun``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Returns the stream without the maximal prefix of elements that satisfy the
 given predicate given as a function.
</summary>
</member>
<member name="M:Hopac.Stream.skipWhileJob``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Returns the stream without the maximal prefix of elements that satisfy the
 given predicate given as a job.
</summary>
</member>
<member name="M:Hopac.Stream.takeUntil``2(Hopac.Alt{``0},Hopac.Promise{Hopac.Stream.Cons{``1}})">
<summary>
 Returns a stream that produces elements from the given stream until the
 given alternative is committed to after which the returned stream is
 closed.  Note that `append (takeUntil evt xs) (skipUntil evt xs)` may not
 be equivalent to `xs`, because there is an inherent race-condition.  See
 also: `takeAndSkipUntil`.
</summary>
</member>
<member name="M:Hopac.Stream.takeAndSkipUntil``2(Hopac.Alt{``0},Hopac.Promise{Hopac.Stream.Cons{``1}})">
<summary>
 Returns a pair of streams of which the first one takes elements from the
 given stream and the second skips elements from the given stream until the
 given alternative is committed to.  It is guaranteed that
 `takeAndSkipUntil evt xs |&gt; fun (hs, ts) -&gt; append hs ts` is equivalent to
 `xs`.  See also: `skipUntil`, `takeUntil`.
</summary>
</member>
<member name="M:Hopac.Stream.skipUntil``2(Hopac.Alt{``0},Hopac.Promise{Hopac.Stream.Cons{``1}})">
<summary>
 Returns a stream that discards elements from the given stream until the
 given alternative is committed to after which the remainder of the given
 stream is produced.  Note that `append (takeUntil evt xs) (skipUntil evt
 xs)` may not be equivalent to `xs`, because there is an inherent
 race-condition.  See also: `takeAndSkipUntil`.
</summary>
</member>
<member name="M:Hopac.Stream.take``1(System.Int64,Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 `take n` returns a stream that has the first `n` elements of the given
 stream.  If the given stream is shorter than `n`, then `take n` is the
 identity function.  Note that if `n` is non-negative, then `append (take n
 xs) (skip n xs)` is equivalent to `xs`.
</summary>
</member>
<member name="M:Hopac.Stream.skip``1(System.Int64,Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 `skip n xs` returns a stream without the first `n` elements of the given
 stream.  If the given stream is shorter than `n`, then the returned stream
 will be empty.  Note that if `n` is non-negative, then `append (take n xs)
 (skip n xs)` is equivalent to `xs`.
</summary>
</member>
<member name="M:Hopac.Stream.switchMap``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Maps and joins all the streams together with `switch`.  This is perhaps
 the most useful binding form with choice streams as this correspond to the
 idea of producing results based only on the latest source of information.
</summary>
</member>
<member name="M:Hopac.Stream.appendMap``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Maps and joins all the streams together with `append`.  This is roughly
 the same function as `Seq.collect`, but is probably less frequently used
 with choice streams.
</summary>
</member>
<member name="M:Hopac.Stream.mergeMap``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Maps and joins all the streams together with `merge`.  This corresponds to
 interleaving results based on all sources of information.  While this is a
 theoretically important combinator, `mergeMap` is probably not the most
 useful binding form on choice streams.
</summary>
</member>
<member name="M:Hopac.Stream.ambMap``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Maps and joins all the streams together with `amb`.  This corresponds to
 the idea of starting several alternative streams in parallel and then only
 using the one that produces the first result.
</summary>
</member>
<member name="M:Hopac.Stream.mapJoin``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Hopac.Promise{Hopac.Stream.Cons{``1}},``2}},Microsoft.FSharp.Core.FSharpFunc{``3,``0},Hopac.Promise{Hopac.Stream.Cons{``3}})">
<summary>
 `mapJoin j f xs` is equivalent to `joinWith j (mapFun f xs)`.
</summary>
</member>
<member name="M:Hopac.Stream.switchAll``2(Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Joins all the streams together with `switch`.
</summary>
</member>
<member name="M:Hopac.Stream.appendAll``2(Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Joins all the streams together with `append`.
</summary>
</member>
<member name="M:Hopac.Stream.mergeAll``2(Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Joins all the streams together with `merge`.
</summary>
</member>
<member name="M:Hopac.Stream.ambAll``2(Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Joins all the streams together with `amb`.
</summary>
</member>
<member name="M:Hopac.Stream.joinWith``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Hopac.Promise{Hopac.Stream.Cons{``1}},``2}},Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Joins all the streams in the given stream of streams together with the
 given binary join combinator.
</summary>
</member>
<member name="M:Hopac.Stream.switchTo``1(Hopac.Promise{Hopac.Stream.Cons{``0}},Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 `switchTo lhs rhs` is equivalent to `switch rhs lhs`.
</summary>
</member>
<member name="M:Hopac.Stream.switch``1(Hopac.Promise{Hopac.Stream.Cons{``0}},Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream that produces elements from the first stream as long as
 the second stream produces no elements.  As soon as the second stream
 produces an element, the returned stream only produces elements from the
 second stream.  See also: `switchTo`, `switchMap`, `never`.
</summary>
</member>
<member name="M:Hopac.Stream.append``1(Hopac.Promise{Hopac.Stream.Cons{``0}},Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Concatenates the given two streams.  In other words, returns a stream that
 first produces all the elements from first stream and then all the
 elements from the second stream.  If the first stream is infinite,
 `append` should not be used, because no elements would be produced from
 the second stream.  See also: `appendMap`, `nil`.
</summary>
</member>
<member name="M:Hopac.Stream.merge``1(Hopac.Promise{Hopac.Stream.Cons{``0}},Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream that produces elements from both of the given streams so
 that elements from the streams are interleaved non-deterministically in
 the returned stream.  See also: `mergeMap`, `nil`.
</summary>
</member>
<member name="M:Hopac.Stream.amb``1(Hopac.Promise{Hopac.Stream.Cons{``0}},Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Of the two given streams, returns the stream that first produces an
 element or is closed.  See also: `ambMap`, `never`.
</summary>
</member>
<member name="M:Hopac.Stream.distinctUntilChanged``1(Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream that contains no successive duplicate elements.
</summary>
</member>
<member name="M:Hopac.Stream.distinctUntilChangedByFun``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream that contains no successive duplicate elements based on
 the keys returned by the given function.
</summary>
</member>
<member name="M:Hopac.Stream.distinctUntilChangedByJob``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream that contains no successive duplicate elements based on
 the keys returned by the given job.
</summary>
</member>
<member name="M:Hopac.Stream.distinctUntilChangedWithFun``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream that contains no successive duplicate elements according
 to the given comparison function.
</summary>
</member>
<member name="M:Hopac.Stream.distinctUntilChangedWithJob``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream that contains no successive duplicate elements according
 to the given comparison job.
</summary>
</member>
<member name="M:Hopac.Stream.distinctByFun``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream that contains no duplicate entries based on the keys
 returned by the given function.
</summary>
</member>
<member name="M:Hopac.Stream.distinctByJob``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream that contains no duplicate entries based on the keys
 returned by the given job.
</summary>
</member>
<member name="M:Hopac.Stream.scanFromFun``2(``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},Hopac.Promise{Hopac.Stream.Cons{``1}})">
<summary>
 `scanFromFun s sx2sJ xs` is equivalent to `scanFun sx2sJ s xs` and is
 often syntactically more convenient to use.
</summary>
</member>
<member name="M:Hopac.Stream.scanFromJob``3(``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Hopac.Promise{Hopac.Stream.Cons{``1}})">
<summary>
 `scanFromJob s sx2sJ xs` is equivalent to `scanJob sx2sJ s xs` and is
 often syntactically more convenient to use.
</summary>
</member>
<member name="M:Hopac.Stream.scanFun``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,Hopac.Promise{Hopac.Stream.Cons{``1}})">
<summary>
 Returns a stream whose elements are computed using the given function and
 initial state as with `foldFun`.
</summary>
</member>
<member name="M:Hopac.Stream.scanJob``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0,Hopac.Promise{Hopac.Stream.Cons{``1}})">
<summary>
 Returns a stream whose elements are computed using the given job and
 initial state as with `foldJob`.
</summary>
</member>
<member name="M:Hopac.Stream.zipWithFun``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Hopac.Promise{Hopac.Stream.Cons{``0}},Hopac.Promise{Hopac.Stream.Cons{``1}})">
<summary>
 `zipWithFun f xs ys` is equivalent to `zip xs ys |&gt; mapFun (fun (x, y) -&gt;
 f x y)`.
</summary>
</member>
<member name="M:Hopac.Stream.zip``2(Hopac.Promise{Hopac.Stream.Cons{``0}},Hopac.Promise{Hopac.Stream.Cons{``1}})">
<summary>
 Returns a stream of pairs of elements from the given pair of streams.  No
 elements from either stream are skipped and each element is used only
 once.  In `zip xs ys`, the `xs` stream is examined first.  See also:
 `pullOn`, `combineLatest`.
</summary>
</member>
<member name="M:Hopac.Stream.buffer``1(System.Int32,Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Converts a stream of elements into a stream of non-overlapping buffers of
 at most given number of elements.
</summary>
</member>
<member name="M:Hopac.Stream.groupByFun``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Hopac.Job{Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{Hopac.Promise{Hopac.Stream.Cons{``1}},``2}}},Microsoft.FSharp.Core.FSharpFunc{``1,``0},Hopac.Promise{Hopac.Stream.Cons{``1}})">
<summary>
 `groupByJob newGroup keyOf elems` splits the given source stream into
 substreams or groups based on the keys extracted from the elements by
 `keyOf` and formed using `newGroup`.  See `groupByJob` for further
 details.
</summary>
</member>
<member name="M:Hopac.Stream.groupByJob``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Hopac.Job{Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{Hopac.Promise{Hopac.Stream.Cons{``1}},``2}}},Microsoft.FSharp.Core.FSharpFunc{``1,``4},Hopac.Promise{Hopac.Stream.Cons{``1}})">
<summary>
 `groupByJob newGroup keyOf elems` splits the given source stream into
 substreams or groups based on the keys extracted from the elements by
 `keyOf` and formed using `newGroup`.  See also: `groupByFun`.
</summary>
</member>
<member name="M:Hopac.Stream.mapIgnore``1(Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 `xs |&gt; mapIgnore` is equivalent to `xs |&gt; mapConst ()`.
</summary>
</member>
<member name="M:Hopac.Stream.mapConst``2(``0,Hopac.Promise{Hopac.Stream.Cons{``1}})">
<summary>
 Returns a stream that produces the given element each time the given
 stream produces an element.
</summary>
</member>
<member name="M:Hopac.Stream.mapFun``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream that produces elements passed through the given function
 whenever the given streams produces elements.  `mapFun x2y` is equivalent
 to `mapJob (Job.lift x2y)`.
</summary>
</member>
<member name="M:Hopac.Stream.mapJob``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream that produces elements passed through the given job
 whenever the given streams produces elements.
</summary>
</member>
<member name="M:Hopac.Stream.filterFun``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream that contains the elements from the given stream for
 which the given function returns `true`.
</summary>
</member>
<member name="M:Hopac.Stream.filterJob``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream that contains the elements from the given stream for
 which the given job returns `true`.
</summary>
</member>
<member name="M:Hopac.Stream.choose``1(Hopac.Promise{Hopac.Stream.Cons{Microsoft.FSharp.Core.FSharpOption{``0}}})">
<summary>
 `xs |&gt; choose` is equivalent to `xs |&gt; chooseFun id`.
</summary>
</member>
<member name="M:Hopac.Stream.chooseFun``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream that produces results whenever the given stream produces
 an element and the given function returns `Some` result from that element.
</summary>
</member>
<member name="M:Hopac.Stream.chooseJob``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream that produces results whenever the given stream produces
 an element and the given job returns `Some` result from that element.
</summary>
</member>
<member name="M:Hopac.Stream.toObservable``1(Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Returns an observable that eagerly consumes the given stream.
</summary>
</member>
<member name="M:Hopac.Stream.ofObservable``1(System.IObservable{``0})">
<summary>
 `ofObservable xO` is equivalent to `ofObservableOn null xO`.  Note that it
 is often necessary to specify the synchronization context to subscribe on.
 See also: `Observable.SubscribeOn`.
</summary>
</member>
<member name="M:Hopac.Stream.ofObservableOnMain``1(System.IObservable{``0})">
<summary>
 `ofObservableOnMain xO` is equivalent to `ofObservable main xO`, where
 `main` is the main synchronization context as set by application code
 using `setMain`.
</summary>
</member>
<member name="M:Hopac.Stream.ofObservableOn``1(System.Threading.SynchronizationContext,System.IObservable{``0})">
<summary>
 Subscribes to the given observable on the specified synchronization
 context and returns the events pushed by the observable as a stream.  A
 finalizer is used to automatically unsubscribe from the observable after
 the stream is no longer reachable.
</summary>
</member>
<member name="M:Hopac.Stream.cycle``1(Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 Creates an infinite repetition of the given stream.  For infinite streams
 `cycle` is the identity function.
</summary>
</member>
<member name="M:Hopac.Stream.repeat``1(``0)">
<summary>
 Creates an infinite stream of the given value.
</summary>
</member>
<member name="M:Hopac.Stream.iterateFun``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``0)">
<summary>
 Returns an infinite stream of repeated applications of the given function
 to the given initial value.
</summary>
</member>
<member name="M:Hopac.Stream.iterateJob``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0)">
<summary>
 Returns an infinite stream of repeated applications of the given job to
 the given initial value.
</summary>
</member>
<member name="M:Hopac.Stream.generateFun``2(``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Core.FSharpFunc{``0,``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Generates a stream.
</summary>
</member>
<member name="M:Hopac.Stream.generateFuns``2(``0,Hopac.Stream.GenerateFuns{``0,``1})">
<summary>
 Generates a stream from the given state using the given function object.
</summary>
</member>
<member name="M:Hopac.Stream.unfoldFun``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{System.Tuple{``1,``0}}},``0)">
<summary>
 Returns a lazy stream that contains the elements generated by the given
 function.
</summary>
</member>
<member name="M:Hopac.Stream.unfoldJob``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0)">
<summary>
 Returns a lazy stream that contains the elements generated by the given
 job.  See also: `foldBack`.
</summary>
</member>
<member name="M:Hopac.Stream.once``1(Hopac.Job{``0})">
<summary>
 Returns a lazy stream that, when pulled, runs the given job, produces the
 result of the job and closes.  `once xJ` is equivalent to `indefinitely xJ
 |&gt; take 1`.
</summary>
</member>
<member name="M:Hopac.Stream.indefinitely``1(Hopac.Job{``0})">
<summary>
 Returns a lazy stream whose elements are generated by running the given
 job.  For example, given a channel, `xCh`, a stream can be created,
 `indefinitely xCh`, through which all the values given on the channel can
 be observed.  See also: `values`.
</summary>
</member>
<member name="M:Hopac.Stream.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Converts the given sequence to a lazy stream.
</summary>
</member>
<member name="M:Hopac.Stream.one``1(``0)">
<summary>
 Returns a stream of length one containing the given value.  `one x` is
 equivalent to `cons x nil`.
</summary>
</member>
<member name="M:Hopac.Stream.error``1(System.Exception)">
<summary>
 Constructs a choice stream that is closed with an error.
</summary>
</member>
<member name="M:Hopac.Stream.never``1">
<summary>
 A choice stream that never produces any values and never closes.  While
 perhaps rarely used, this is theoretically important as the identity
 element for the `switch` and `amb` combinators.
</summary>
</member>
<member name="M:Hopac.Stream.delay``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 `delay` creates a stream that is constructed lazily.  Use `delay` to make
 lazy streams and to avoid unbounded eager recursion.
</summary>
</member>
<member name="M:Hopac.Stream.cons``1(``0,Hopac.Promise{Hopac.Stream.Cons{``0}})">
<summary>
 `cons x xs` constructs a choice stream whose first value is `x` and the
 rest of the stream is computed using `xs`.  For example, `cons 1 &lt;&lt; cons 2
 &lt;&lt; cons 3 &lt;| cons 4 nil` is a stream producing the sequence `1 2 3 4`.
 See also: `delay`.
</summary>
</member>
<member name="M:Hopac.Stream.nil``1">
<summary>
 An empty or closed choice stream.  `nil` is also the identity element for
 the `merge` and `append` combinators.  `nil` is equivalent to
 `Promise.Now.withValue Nil`.
</summary>
</member>
<member name="M:Hopac.Stream.MVar.tap``1(Hopac.Stream.MVar{``0})">
<summary>
 Returns the generated stream, including the current value of the
 variable, from the point in time when `tap` is called.
</summary>
</member>
<member name="M:Hopac.Stream.MVar.updateJob``2(Hopac.Stream.MVar{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Creates a job that updates the value of the variable with the given job
 in a serialized fashion.  If the job raises an exception, the variable
 will not be modified.  See also: `updateFun`.
</summary>
</member>
<member name="M:Hopac.Stream.MVar.updateFun``1(Hopac.Stream.MVar{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``0})">
<summary>
 Creates a job that updates the value of the variable with the given
 function in a serialized fashion.  If the function raises an exception,
 the variable will not be modified.  See also: `updateJob`.
</summary>
</member>
<member name="M:Hopac.Stream.MVar.set``1(Hopac.Stream.MVar{``0},``0)">
<summary>
 Creates a job that sets the value of the variable.  Note that a
 combination of `get` and `set` is not serialized.  See also:
 `updateFun`.
</summary>
</member>
<member name="M:Hopac.Stream.MVar.get``1(Hopac.Stream.MVar{``0})">
<summary>
 Returns a job that gets the value of the variable.
</summary>
</member>
<member name="M:Hopac.Stream.MVar.create``1(``0)">
<summary>
 Creates a new serialized stream variable.
</summary>
</member>
<member name="T:Hopac.Stream.MVar">
<summary>
 Operations on serialized stream variables.
</summary>
</member>
<member name="M:Hopac.Stream.Var.tap``1(Hopac.Stream.Var{``0})">
<summary>
 Returns the generated stream, including the current value of the
 variable, from the point in time when `tap` is called.
</summary>
</member>
<member name="M:Hopac.Stream.Var.set``1(Hopac.Stream.Var{``0},``0)">
<summary>
 Sets the value of the variable and appends the value to the end of the
 generated stream.  Note that while this operation is atomic, and can be
 safely used from multiple parallel jobs, a combination of `get` and
 `set` is not atomic.  See also: `MVar&lt;&apos;x&gt;`.
</summary>
</member>
<member name="M:Hopac.Stream.Var.get``1(Hopac.Stream.Var{``0})">
<summary>
 Gets the value of the variable.
</summary>
</member>
<member name="M:Hopac.Stream.Var.create``1(``0)">
<summary>
 Creates a new stream variable.
</summary>
</member>
<member name="T:Hopac.Stream.Var">
<summary>
 Operations on stream variables.
</summary>
</member>
<member name="M:Hopac.Stream.Src.tap``1(Hopac.Stream.Src{``0})">
<summary>
 Returns the remainder of the generated stream after the point in time
 when `tap` is called.
</summary>
</member>
<member name="M:Hopac.Stream.Src.close``1(Hopac.Stream.Src{``0})">
<summary>
 Terminates the stream.
</summary>
</member>
<member name="M:Hopac.Stream.Src.error``1(Hopac.Stream.Src{``0},System.Exception)">
<summary>
 Terminates the stream with an error.  The given exception is raised in
 the consumers of the stream if and when they reach the end of the
 stream.
</summary>
</member>
<member name="M:Hopac.Stream.Src.value``1(Hopac.Stream.Src{``0},``0)">
<summary>
 Appends a new value to the end of the generated stream.  This operation
 is atomic and non-blocking and can be safely used from multiple parallel
 jobs.
</summary>
</member>
<member name="M:Hopac.Stream.Src.create``1">
<summary>
 Creates a new stream source.
</summary>
</member>
<member name="T:Hopac.Stream.Src">
<summary>
 Operations on stream sources.
</summary>
</member>
<member name="T:Hopac.Stream">
<summary>
 Operations on choice streams.
</summary>
</member>
<member name="M:Hopac.Timer.Global.timeOutMillis(System.Int32)">
<summary>
 `timeOutMillis n` is equivalent to `timeOut (TimeSpan.FromMilliseconds
 (float n))`.
</summary>
</member>
<member name="M:Hopac.Timer.Global.timeOut(System.TimeSpan)">
<summary>
 Creates an alternative that, after instantiation, becomes available
 after the specified time span.
</summary>
</member>
<member name="T:Hopac.Timer.Global">
<summary>
 Operations on the global wall-clock timer.  The global timer is implicitly
 associated with the global scheduler.
</summary>
</member>
<member name="T:Hopac.Timer">
<summary>
 Operations on a wall-clock timer.
</summary>
</member>
<member name="T:Hopac.TopLevel.Stream`1">
<summary>
 Represents a non-deterministic stream of values called a choice stream.
</summary>
</member>
<member name="M:Hopac.TopLevel.memo``1(Hopac.Job{``0})">
<summary>
 Creates a promise whose value is computed lazily with the given job when
 an attempt is made to read the promise.  This is the same function as
 `Promise.Now.delay`.
</summary>
</member>
<member name="M:Hopac.TopLevel.timeOutMillis(System.Int32)">
<summary>
 Creates a timeout for the specified number of milliseconds.  This is the
 same function as `Timer.Global.timeOutMillis`.
</summary>
</member>
<member name="M:Hopac.TopLevel.timeOut(System.TimeSpan)">
<summary>
 Creates a timeout for the specified time span.  This is the same function
 as `Timer.Global.timeOut`.
</summary>
</member>
<member name="M:Hopac.TopLevel.mvarFull``1(``0)">
<summary>
 Creates a new serialized variable that initially contains the given value.
 This is the same function as `MVar.Now.createFull`.
</summary>
</member>
<member name="M:Hopac.TopLevel.mvar``1">
<summary>
 Creates a serialized variable that is initially empty.  This is the same
 function as `MVar.Now.create`.
</summary>
</member>
<member name="M:Hopac.TopLevel.ivarFull``1(``0)">
<summary>
 Creates a new write once variable with the given value.  This is the same
 function as `IVar.Now.createFull`.
</summary>
</member>
<member name="M:Hopac.TopLevel.ivar``1">
<summary>
 Creates a new write once variable.  This is the same function as
 `IVar.Now.create`.
</summary>
</member>
<member name="M:Hopac.TopLevel.mb``1">
<summary>
 Creates a new mailbox.  This is the same function as
 `Mailbox.Now.create`.
</summary>
</member>
<member name="M:Hopac.TopLevel.ch``1">
<summary>
 Creates a new channel.  This is the same function as `Ch.Now.create`.
</summary>
</member>
<member name="M:Hopac.TopLevel.asJob``1(Hopac.Job{``0})">
<summary>
 Use object as job.  This function is a NOP and is provided as a kind of
 syntactic alternative to using a type ascription or an `upcast`.
</summary>
</member>
<member name="M:Hopac.TopLevel.asAlt``1(Hopac.Alt{``0})">
<summary>
 Use object as alternative.  This function is a NOP and is provided as a
 kind of syntactic alternative to using a type ascription or an `upcast`.
</summary>
</member>
<member name="M:Hopac.TopLevel.server(Hopac.Job{Hopac.Void})">
<summary>
 Starts running the given job on the global scheduler like `start`, but the
 given job is known never to return normally, so the job can be spawned in
 an even more lightweight manner.
</summary>
</member>
<member name="M:Hopac.TopLevel.queueDelay``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Queues the given delayed job for execution on the global scheduler.
 `queueDelay u2xJ` is equivalent to `queueIgnore &lt;| Job.delay u2xJ`.
</summary>
</member>
<member name="M:Hopac.TopLevel.queueIgnore``1(Hopac.Job{``0})">
<summary>
 Queues the given job for execution on the global scheduler.  `queueIgnore
 xJ` is equivalent to `Job.Ignore xJ |&gt; queue`.
</summary>
</member>
<member name="M:Hopac.TopLevel.queue(Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Queues the given job for execution on the global scheduler.  See also:
 `start`, `server`.
</summary>
</member>
<member name="M:Hopac.TopLevel.startDelay``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Starts running the given delayed job on the global scheduler, but does not
 wait for the job to finish.  `startDelay u2xJ` is equivalent to
 `startIgnore &lt;| Job.delay u2xJ`.
</summary>
</member>
<member name="M:Hopac.TopLevel.startIgnore``1(Hopac.Job{``0})">
<summary>
 Starts running the given job on the global scheduler, but does not wait
 for the job to finish.  `startIgnore xJ` is equivalent to `Job.Ignore xJ
 |&gt; start`.
</summary>
</member>
<member name="M:Hopac.TopLevel.start(Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Starts running the given job on the global scheduler, but does not wait
 for the job to finish.  See also: `queue`, `server`.
</summary>
</member>
<member name="M:Hopac.TopLevel.run``1(Hopac.Job{``0})">
<summary>
 Starts running the given job on the global scheduler and then blocks the
 current thread waiting for the job to either return successfully or fail.
 See also: `start`.
</summary>
</member>
<member name="P:Hopac.TopLevel.onMain">
<summary>
 Builder for running an async workflow on the main synchronization context
 and interoperating with the Hopac global scheduler.  The application must
 call `Hopac.Extensions.Async.setMain` to configure Hopac with the main
 synchronization context.
</summary>
</member>
<member name="P:Hopac.TopLevel.job">
<summary>
 Default expression builder for jobs.
</summary>
</member>
<member name="T:Hopac.TopLevel">
<summary>
 Convenience bindings for programming with Hopac.
</summary>
</member>
<member name="">

</member>
<member name="T:System.AssemblyVersionInformation">

</member>
</members>
</doc>
